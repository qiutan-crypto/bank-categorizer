<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Bank Transaction Categorizer</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <script src="https://cdn.sheetjs.com/xlsx-0.20.1/package/dist/xlsx.full.min.js"></script>
  <style>
    th.no-copy,
    td.no-copy {
      user-select: none;
      -webkit-user-select: none;
      -moz-user-select: none;
      -ms-user-select: none;
    }

    .action-card {
      background: rgba(255, 255, 255, 0.14);
      border-radius: 1rem;
      padding: 1rem;
      box-shadow: 0 12px 30px rgba(15, 23, 42, 0.15);
      backdrop-filter: blur(8px);
      border: 1px solid rgba(255, 255, 255, 0.35);
      display: flex;
      flex-direction: column;
      gap: 0.75rem;
    }

    .action-group-title {
      font-size: 0.85rem;
      letter-spacing: 0.08em;
      text-transform: uppercase;
      color: rgba(255, 255, 255, 0.75);
      font-weight: 700;
    }

    .action-card .action-description {
      font-size: 0.75rem;
      color: rgba(255, 255, 255, 0.7);
      line-height: 1.25;
    }

    .action-pill {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      padding: 0.55rem 1.1rem;
      border-radius: 9999px;
      font-weight: 600;
      font-size: 0.9rem;
      color: #0f172a;
      background: #ffffff;
      box-shadow: 0 8px 16px rgba(15, 23, 42, 0.18);
      cursor: pointer;
      border: none;
      transition: transform 150ms ease, box-shadow 150ms ease;
      min-width: 9rem;
      text-align: center;
    }

    .action-pill:hover {
      transform: translateY(-1px);
      box-shadow: 0 12px 20px rgba(15, 23, 42, 0.25);
    }

    .action-pill--accent {
      background: #ecfdf5;
      color: #047857;
    }

    .action-pill:disabled {
      opacity: 0.6;
      cursor: not-allowed;
      box-shadow: none;
      transform: none;
    }
  </style>
</head>
<body class="min-h-screen bg-gray-100 text-gray-800">
  <!-- Header -->
  <header class="bg-gradient-to-r from-emerald-500 to-cyan-500 text-white py-6 shadow">
    <div class="max-w-7xl mx-auto px-4 flex flex-col gap-5">
      <div class="flex flex-col sm:flex-row sm:items-center sm:justify-between gap-3">
        <div>
          <h1 class="text-2xl font-bold">Bank Transaction Categorizer</h1>
          <p id="current-file-label" class="text-sm opacity-90 hidden"></p>
        </div>
      </div>
      <div class="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 gap-3">
        <div class="action-card">
          <p class="action-group-title">Transactions &amp; Rules</p>
          <div class="flex flex-wrap gap-2">
            <label class="action-pill">
              <input id="tx-input" type="file" accept=".xlsx,.xls,.csv" multiple class="hidden" />
              Load Transactions
            </label>
            <label class="action-pill">
              <input id="rules-input" type="file" accept=".json,.csv,.txt" class="hidden" />
              Load Rules
            </label>
          </div>
          <p class="action-description">Upload spreadsheets and auto-classification rules to start categorizing.</p>
        </div>
        <div class="action-card">
          <p class="action-group-title">Local Projects</p>
          <div class="flex flex-wrap gap-2">
            <label class="action-pill">
              <input id="project-load-input" type="file" accept=".json" class="hidden" />
              Load Project
            </label>
            <button id="export-project-button" type="button" class="action-pill action-pill--accent">
              Export Project
            </button>
          </div>
          <p class="action-description">Quickly restore or backup your work as JSON files on your device.</p>
        </div>
        <div class="action-card">
          <p class="action-group-title">Server Projects</p>
          <div class="flex flex-wrap gap-2">
            <button id="save-project-server-button" type="button" class="action-pill">
              Save to Server
            </button>
            <button id="load-project-server-button" type="button" class="action-pill">
              Load from Server
            </button>
          </div>
          <p class="action-description">Persist snapshots on Render so your team can resume anywhere.</p>
        </div>
      </div>
    </div>
  </header>

  <main class="max-w-7xl mx-auto px-4 py-6">
    <!-- Tabs -->
    <div class="mb-6">
      <div id="tabs" class="inline-flex gap-2 bg-white p-2 rounded-lg shadow-sm">
        <button data-tab="unassigned" class="tab-btn px-4 py-2 rounded-md text-sm font-semibold bg-indigo-50 text-indigo-700">Unassigned Transactions <span id="tab-unassigned-count" class="text-xs font-normal opacity-75">(0)</span></button>
        <button data-tab="assigned" class="tab-btn px-4 py-2 rounded-md text-sm font-semibold">Assigned Transactions <span id="tab-assigned-count" class="text-xs font-normal opacity-75">(0)</span></button>
        <button data-tab="reports" class="tab-btn px-4 py-2 rounded-md text-sm font-semibold">Reports</button>
        <button data-tab="exports" class="tab-btn px-4 py-2 rounded-md text-sm font-semibold">Exports</button>
        <button data-tab="coa" class="tab-btn px-4 py-2 rounded-md text-sm font-semibold">Chart of Accounts</button>
        <button data-tab="reconcile" class="tab-btn px-4 py-2 rounded-md text-sm font-semibold">Reconcile</button>
  </div>
</div>

  <!-- Reconcile balances modal -->
  <div id="reconcile-modal" class="fixed inset-0 hidden items-center justify-center bg-black bg-opacity-40 z-50">
    <div class="bg-white rounded-lg shadow-lg w-full max-w-md p-4">
      <h3 class="font-bold mb-3">Set Statement Balances</h3>
      <div class="space-y-3">
        <div>
          <label for="reconcile-beginning-input" class="block text-sm font-medium text-gray-700 mb-1">Beginning Balance</label>
          <input id="reconcile-beginning-input" type="number" step="0.01" class="w-full rounded-md border border-slate-300 px-3 py-2 focus:outline-none focus:ring-2 focus:ring-indigo-500" placeholder="e.g., 25775.30">
        </div>
        <div>
          <label for="reconcile-statement-input" class="block text-sm font-medium text-gray-700 mb-1">Statement Ending Balance</label>
          <input id="reconcile-statement-input" type="number" step="0.01" class="w-full rounded-md border border-slate-300 px-3 py-2 focus:outline-none focus:ring-2 focus:ring-indigo-500" placeholder="e.g., 18066.16">
        </div>
        <div class="bg-slate-50 border border-slate-200 rounded-md px-3 py-2 text-sm text-gray-600">
          <div class="flex justify-between"><span>Beginning Balance:</span><span id="reconcile-preview-beginning">$0.00</span></div>
          <div class="flex justify-between"><span>Statement Balance:</span><span id="reconcile-preview-statement">$0.00</span></div>
          <div class="flex justify-between font-semibold"><span>Difference:</span><span id="reconcile-preview-difference">$0.00</span></div>
        </div>
      </div>
      <div class="flex justify-end gap-2 mt-4">
        <button id="reconcile-cancel" class="px-3 py-2 rounded-md bg-slate-200">Cancel</button>
        <button id="reconcile-save" class="px-3 py-2 rounded-md bg-emerald-600 text-white">Save</button>
      </div>
    </div>
  </div>

    <!-- Tab contents -->
    <section id="tab-contents">
      <!-- Unassigned -->
      <div data-content="unassigned" class="tab-content bg-white rounded-lg shadow p-4">
        <div class="flex items-center justify-between mb-3">
          <h2 class="font-bold text-lg">Unassigned Transactions</h2>
          <div class="flex items-center gap-2">
            <button id="copy-selection-button" class="px-3 py-2 bg-slate-600 text-white rounded-md shadow hover:opacity-90 disabled:opacity-50" disabled>Copy Selected</button>
            <button id="reclassify-button" class="px-3 py-2 bg-emerald-500 text-white rounded-md shadow hover:opacity-90 disabled:opacity-50" disabled>Reclassify Selected</button>
            <button id="bulk-apply-gpt" class="px-3 py-2 bg-indigo-600 text-white rounded-md shadow hover:opacity-90">Paste Rule</button>
          </div>
        </div>
        <div class="overflow-x-auto rounded-md border">
          <table id="unassigned-table" class="min-w-full text-sm table-auto">
            <thead id="unassigned-head" class="bg-gray-50 sticky top-0"></thead>
            <tbody id="unassigned-body" class="bg-white"></tbody>
          </table>
        </div>
      </div>

      <!-- Assigned -->
      <div data-content="assigned" class="tab-content hidden bg-white rounded-lg shadow p-4">
        <div class="flex items-center justify-between mb-3">
          <h2 class="font-bold text-lg">Assigned Transactions</h2>
          <div class="flex items-center gap-2">
            <button id="deselect-filters" class="px-3 py-2 bg-slate-200 rounded-md">Deselect</button>
            <button id="copy-selection-assigned" class="px-3 py-2 bg-slate-600 text-white rounded-md shadow hover:opacity-90 disabled:opacity-50" disabled>Copy Selected</button>
            <button id="assigned-reclassify-button" class="px-3 py-2 bg-amber-500 text-white rounded-md shadow hover:opacity-90" disabled>Reclassify Selected</button>
          </div>
        </div>
        <div class="overflow-x-auto rounded-md border">
          <table id="assigned-table" class="min-w-full text-sm table-auto">
            <thead id="assigned-head" class="bg-gray-50 sticky top-0"></thead>
            <tbody id="assigned-body" class="bg-white"></tbody>
          </table>
        </div>
      </div>

      <!-- Reports -->
      <div data-content="reports" class="tab-content hidden bg-white rounded-lg shadow p-4">
        <div class="mb-4">
          <div id="report-view-tabs" class="inline-flex gap-2 bg-gray-100 p-1 rounded-md">
            <button data-report-tab="pl" class="report-tab-btn px-3 py-1.5 text-sm font-semibold rounded-md bg-white text-indigo-600 shadow">Profit &amp; Loss</button>
            <button data-report-tab="balance" class="report-tab-btn px-3 py-1.5 text-sm font-semibold text-gray-600 rounded-md">Balance Sheet</button>
          </div>
        </div>

        <div data-report-content="pl" class="space-y-6">
          <h2 class="font-bold text-lg">Profit and Loss Report</h2>
          <div class="grid md:grid-cols-3 gap-4">
            <div class="md:col-span-2 bg-white rounded-lg shadow-sm p-4">
              <div class="grid md:grid-cols-2 gap-4">
                <div class="bg-white rounded-lg p-3 shadow-sm border border-slate-200">
                  <h3 class="text-sm font-semibold text-gray-600 mb-2">Income</h3>
                  <table id="report-income" class="min-w-full text-sm"></table>
                </div>
                <div class="bg-white rounded-lg p-3 shadow-sm border border-slate-200">
                  <h3 class="text-sm font-semibold text-gray-600 mb-2">Expenses</h3>
                  <div class="text-xs text-gray-500 mb-2">Only expense-type accounts are included here; equity and liability accounts are excluded.</div>
                  <table id="report-expense" class="min-w-full text-sm"></table>
                </div>
              </div>
            </div>
            <div class="bg-white rounded-lg shadow-sm p-4 space-y-3">
              <div class="p-3 rounded-lg bg-green-50">
                <div class="text-sm text-gray-600">Total Income</div>
                <div id="total-income" class="text-green-600 text-lg font-bold">$0.00</div>
              </div>
              <div class="p-3 rounded-lg bg-red-50">
                <div class="text-sm text-gray-600">Total Expenses</div>
                <div id="total-expense" class="text-red-600 text-lg font-bold">$0.00</div>
              </div>
              <div class="p-3 rounded-lg bg-white border">
                <div class="text-sm text-gray-600">Net Profit</div>
                <div id="net-profit" class="text-lg font-bold">$0.00</div>
              </div>
            </div>
          </div>
        </div>

        <div data-report-content="balance" class="hidden space-y-6">
          <h2 class="font-bold text-lg">Balance Sheet</h2>
          <p class="text-xs text-gray-500">Assets are shown on the left; liabilities and equity on the right.</p>
          <div class="grid md:grid-cols-2 gap-4">
            <div class="space-y-3">
              <div class="rounded-lg border border-slate-200 overflow-hidden bg-white">
                <table class="min-w-full text-sm" id="balance-assets-table">
                  <thead class="bg-gray-50">
                    <tr>
                      <th class="px-3 py-2 text-left text-xs font-semibold text-gray-500 uppercase tracking-wide">Account</th>
                      <th class="px-3 py-2 text-right text-xs font-semibold text-gray-500 uppercase tracking-wide">Total</th>
                    </tr>
                  </thead>
                  <tbody id="balance-assets-body"></tbody>
                  <tfoot class="bg-gray-50">
                    <tr>
                      <td class="px-3 py-2 text-sm font-semibold text-gray-700">Total Assets</td>
                      <td class="px-3 py-2 text-sm text-right font-semibold text-gray-700" id="balance-assets-total">$0.00</td>
                    </tr>
                  </tfoot>
                </table>
              </div>
            </div>
            <div class="space-y-4">
              <div class="rounded-lg border border-slate-200 overflow-hidden bg-white">
                <table class="min-w-full text-sm" id="balance-liabilities-table">
                  <thead class="bg-gray-50">
                    <tr>
                      <th class="px-3 py-2 text-left text-xs font-semibold text-gray-500 uppercase tracking-wide">Account</th>
                      <th class="px-3 py-2 text-right text-xs font-semibold text-gray-500 uppercase tracking-wide">Total</th>
                    </tr>
                  </thead>
                  <tbody id="balance-liabilities-body"></tbody>
                  <tfoot class="bg-gray-50">
                    <tr>
                      <td class="px-3 py-2 text-sm font-semibold text-gray-700">Total Liabilities</td>
                      <td class="px-3 py-2 text-sm text-right font-semibold text-gray-700" id="balance-liabilities-total">$0.00</td>
                    </tr>
                  </tfoot>
                </table>
              </div>
              <div class="rounded-lg border border-slate-200 overflow-hidden bg-white">
                <table class="min-w-full text-sm" id="balance-equity-table">
                  <thead class="bg-gray-50">
                    <tr>
                      <th class="px-3 py-2 text-left text-xs font-semibold text-gray-500 uppercase tracking-wide">Account</th>
                      <th class="px-3 py-2 text-right text-xs font-semibold text-gray-500 uppercase tracking-wide">Total</th>
                    </tr>
                  </thead>
                  <tbody id="balance-equity-body"></tbody>
                  <tfoot class="bg-gray-50">
                    <tr>
                      <td class="px-3 py-2 text-sm font-semibold text-gray-700">Total Equity</td>
                      <td class="px-3 py-2 text-sm text-right font-semibold text-gray-700" id="balance-equity-total">$0.00</td>
                    </tr>
                  </tfoot>
                </table>
              </div>
            </div>
          </div>
          <div class="grid gap-3 md:grid-cols-3">
            <div class="rounded-lg border border-slate-200 bg-white px-4 py-3 shadow-sm">
              <div class="text-xs text-gray-500 uppercase tracking-wide">Total Assets</div>
              <div id="balance-total-assets" class="mt-1 text-lg font-bold text-gray-800">$0.00</div>
            </div>
            <div class="rounded-lg border border-slate-200 bg-white px-4 py-3 shadow-sm">
              <div class="text-xs text-gray-500 uppercase tracking-wide">Total Liabilities &amp; Equity</div>
              <div id="balance-total-liabilities-equity" class="mt-1 text-lg font-bold text-gray-800">$0.00</div>
            </div>
            <div id="balance-diff-card" class="rounded-lg border border-slate-200 bg-white px-4 py-3 shadow-sm">
              <div class="text-xs text-gray-500 uppercase tracking-wide">Balance Difference</div>
              <div id="balance-difference" class="mt-1 text-lg font-bold text-gray-800">$0.00</div>
            </div>
          </div>
        </div>
      </div>

      <!-- Exports -->
      <div data-content="exports" class="tab-content hidden bg-white rounded-lg shadow p-4 space-y-5">
        <div class="flex flex-col gap-2 md:flex-row md:items-center md:justify-between">
          <div>
            <h2 class="font-bold text-lg">Export IIF Files</h2>
            <p class="text-sm text-gray-600">Create QuickBooks Desktop IIF files for your chart of accounts and journal entries.</p>
          </div>
        </div>
        <div class="grid gap-4 md:grid-cols-4">
          <div class="rounded-lg border border-slate-200 bg-slate-50 p-4 shadow-sm">
            <h3 class="text-base font-semibold text-gray-800 mb-2">Chart of Accounts</h3>
            <p class="text-xs text-gray-600 mb-3">Exports the accounts referenced by your categorized transactions, including inferred QuickBooks account types.</p>
            <button id="export-coa-button" class="px-4 py-2 bg-emerald-600 text-white rounded-md shadow hover:bg-emerald-500 transition">
              Download COA IIF
            </button>
            <p id="export-coa-message" class="mt-2 text-sm font-semibold text-gray-500"></p>
          </div>
          <div class="rounded-lg border border-slate-200 bg-slate-50 p-4 shadow-sm">
            <h3 class="text-base font-semibold text-gray-800 mb-2">Journal Entries</h3>
            <p class="text-xs text-gray-600 mb-3">Exports categorized transactions as journal entries. Provide the bank account name used on the TRNS line.</p>
            <label for="export-bank-account" class="block text-xs font-semibold text-gray-600 mb-1">Bank Account (TRNS)</label>
            <input id="export-bank-account" type="text" class="w-full rounded-md border border-slate-300 px-3 py-2 text-sm mb-3 focus:outline-none focus:ring-2 focus:ring-indigo-500" placeholder="e.g., 1000 Checking">
            <button id="export-journal-button" class="px-4 py-2 bg-indigo-600 text-white rounded-md shadow hover:bg-indigo-500 transition">
              Download Journal IIF
            </button>
            <p id="export-journal-message" class="mt-2 text-sm font-semibold text-gray-500"></p>
          </div>
          <div class="rounded-lg border border-slate-200 bg-slate-50 p-4 shadow-sm">
            <h3 class="text-base font-semibold text-gray-800 mb-2">Classification Rules</h3>
            <p class="text-xs text-gray-600 mb-3">Exports the loaded rules that matched your categorized transactions, including summary match counts and sample transactions.</p>
            <div class="flex flex-col gap-2">
              <button id="export-rules-csv-button" class="px-4 py-2 bg-slate-500 text-white rounded-md shadow hover:bg-slate-400 transition">
                Download Rules CSV
              </button>
            </div>
            <p id="export-rules-message" class="mt-2 text-sm font-semibold text-gray-500"></p>
          </div>
          <div class="rounded-lg border border-slate-200 bg-slate-50 p-4 shadow-sm">
            <h3 class="text-base font-semibold text-gray-800 mb-2">Classified Transactions</h3>
            <p class="text-xs text-gray-600 mb-3">Exports all categorized transactions to Excel (Date, Description, Amount, and Schedule C Category).</p>
            <button id="export-classified-excel-button" class="px-4 py-2 bg-teal-600 text-white rounded-md shadow hover:bg-teal-500 transition">
              Download Excel
            </button>
            <p id="export-classified-message" class="mt-2 text-sm font-semibold text-gray-500"></p>
          </div>
        </div>
      </div>

      <!-- COA -->
      <div data-content="coa" class="tab-content hidden bg-white rounded-lg shadow p-4">
        <div class="flex items-center justify-between mb-3">
          <h2 class="font-bold text-lg">Chart of Accounts</h2>
          <div class="flex gap-2">
            <button id="add-coa" class="px-3 py-2 bg-indigo-600 text-white rounded-md">Add New Account</button>
            <button id="merge-coa" class="px-3 py-2 bg-slate-200 rounded-md">Merge Duplicates</button>
          </div>
        </div>
        <div class="overflow-x-auto border rounded-md">
          <table id="coa-table" class="min-w-full text-sm">
            <thead class="bg-gray-50">
              <tr>
                <th data-coa-sort="Account Name" aria-sort="none" class="px-3 py-2 text-left cursor-pointer select-none">
                  <span class="inline-flex items-center gap-1">
                    Account Name
                    <span data-coa-sort-indicator class="text-xs text-slate-500 transition-opacity duration-150 opacity-0"></span>
                  </span>
                </th>
                <th data-coa-sort="Account Type" aria-sort="none" class="px-3 py-2 text-left cursor-pointer select-none">
                  <span class="inline-flex items-center gap-1">
                    Account Type
                    <span data-coa-sort-indicator class="text-xs text-slate-500 transition-opacity duration-150 opacity-0"></span>
                  </span>
                </th>
                <th data-coa-sort="Description" aria-sort="none" class="px-3 py-2 text-left cursor-pointer select-none">
                  <span class="inline-flex items-center gap-1">
                    Description
                    <span data-coa-sort-indicator class="text-xs text-slate-500 transition-opacity duration-150 opacity-0"></span>
                  </span>
                </th>
              </tr>
            </thead>
            <tbody id="coa-body" class="bg-white"></tbody>
          </table>
        </div>
      </div>

      <div data-content="reconcile" class="tab-content hidden bg-white rounded-lg shadow p-4 space-y-6">
        <div class="flex flex-col gap-4 lg:flex-row lg:items-center lg:justify-between">
          <div>
            <h2 class="font-bold text-lg">Reconcile</h2>
            <p class="text-sm text-gray-600">Review beginning balance, cleared activity, and compare with your bank statement.</p>
          </div>
          <button id="reconcile-set-balances" class="px-4 py-2 bg-indigo-600 text-white rounded-md shadow hover:bg-indigo-500 transition">
            Set Statement Balances
          </button>
        </div>

        <div class="flex flex-wrap items-center justify-between gap-3">
          <div id="reconcile-view-tabs" class="inline-flex gap-2 bg-gray-100 p-1 rounded-md">
            <button data-reconcile-view="summary" class="reconcile-sub-tab px-3 py-1.5 text-sm font-semibold rounded-md bg-white text-indigo-600 shadow">Summary</button>
            <button data-reconcile-view="detail" class="reconcile-sub-tab px-3 py-1.5 text-sm font-semibold text-gray-600 rounded-md">Monthly Transactions</button>
          </div>
          <div id="reconcile-detail-current-range" class="hidden text-sm text-gray-500 md:text-right"></div>
        </div>

        <div id="reconcile-summary-view" class="space-y-6">
          <div class="grid gap-4 lg:grid-cols-5">
            <div class="rounded-lg border border-slate-200 bg-slate-50 p-4 shadow-sm">
              <div class="text-xs font-semibold text-gray-500 uppercase tracking-wide">Beginning Balance</div>
              <div id="reconcile-beginning" class="mt-1 text-xl font-bold text-gray-800">$0.00</div>
            </div>
            <div class="rounded-lg border border-red-200 bg-red-50 p-4 shadow-sm">
              <div class="flex items-center justify-between text-xs font-semibold text-red-600 uppercase tracking-wide">
                <span>Payments</span>
                <span id="reconcile-payments-count" class="text-[11px] font-medium text-red-500"></span>
              </div>
              <div id="reconcile-payments" class="mt-1 text-xl font-bold text-red-600">-$0.00</div>
            </div>
            <div class="rounded-lg border border-emerald-200 bg-emerald-50 p-4 shadow-sm">
              <div class="flex items-center justify-between text-xs font-semibold text-emerald-600 uppercase tracking-wide">
                <span>Deposits</span>
                <span id="reconcile-deposits-count" class="text-[11px] font-medium text-emerald-500"></span>
              </div>
              <div id="reconcile-deposits" class="mt-1 text-xl font-bold text-emerald-600">$0.00</div>
            </div>
            <div class="rounded-lg border border-slate-200 bg-white p-4 shadow-sm">
              <div class="text-xs font-semibold text-gray-500 uppercase tracking-wide">Cleared Balance</div>
              <div id="reconcile-cleared" class="mt-1 text-xl font-bold text-gray-800">$0.00</div>
            </div>
            <div class="rounded-lg border border-amber-200 bg-amber-50 p-4 shadow-sm">
              <div class="text-xs font-semibold text-amber-600 uppercase tracking-wide">Difference</div>
              <div id="reconcile-difference" class="mt-1 text-xl font-bold text-amber-600">$0.00</div>
              <div id="reconcile-statement" class="mt-2 text-xs text-gray-600">Statement Ending Balance: $0.00</div>
            </div>
          </div>

          <div>
            <h3 class="text-sm font-semibold text-gray-600 mb-2">Monthly Ending Balances</h3>
            <div class="overflow-x-auto border border-slate-200 rounded-md">
              <table class="min-w-full text-sm">
                <thead class="bg-gray-50 text-gray-500 uppercase text-xs tracking-wide">
                  <tr>
                    <th class="px-3 py-2 text-left">Month</th>
                    <th class="px-3 py-2 text-right">Net Activity</th>
                    <th class="px-3 py-2 text-right">Ending Balance</th>
                  </tr>
                </thead>
                <tbody id="reconcile-monthly-body" class="bg-white">
                  <tr>
                    <td class="px-3 py-3 text-center text-gray-400" colspan="3">No transactions available.</td>
                  </tr>
                </tbody>
              </table>
            </div>
          </div>
        </div>

        <div id="reconcile-detail-view" class="space-y-6 hidden">
          <div class="flex flex-col gap-2 md:flex-row md:items-center md:justify-between">
            <p id="reconcile-detail-subtitle" class="text-sm text-gray-600">Select a month from the summary to view its transactions.</p>
            <div class="flex items-center gap-2">
              <button id="reconcile-detail-toggle" class="hidden px-3 py-1.5 text-sm font-semibold rounded-md bg-slate-500 text-white shadow hover:bg-slate-600 transition disabled:opacity-50 disabled:cursor-not-allowed">Switch Debit/Credit</button>
              <button id="reconcile-detail-add" class="hidden px-3 py-1.5 text-sm font-semibold rounded-md bg-indigo-600 text-white shadow hover:bg-indigo-500 transition">Add Transaction</button>
              <button id="reconcile-detail-delete" class="hidden px-3 py-1.5 text-sm font-semibold rounded-md bg-red-600 text-white shadow hover:bg-red-700 transition disabled:opacity-50 disabled:cursor-not-allowed">Delete Selected</button>
            </div>
          </div>

          <div class="overflow-x-auto border border-slate-200 rounded-md">
            <table class="min-w-full text-sm">
              <thead class="bg-gray-50 text-gray-500 uppercase text-xs tracking-wide">
                <tr>
                  <th class="px-3 py-2 text-left"><input id="reconcile-detail-select-all" type="checkbox" class="rounded border-slate-300" /></th>
                  <th class="px-3 py-2 text-left">Date</th>
                  <th class="px-3 py-2 text-left">Description</th>
                  <th class="px-3 py-2 text-right">Withdraw</th>
                  <th class="px-3 py-2 text-right">Deposit</th>
                  <th class="px-3 py-2 text-right">Daily Balance</th>
                  <th class="px-3 py-2 text-right">Actions</th>
                </tr>
              </thead>
              <tbody id="reconcile-detail-body" class="bg-white">
                <tr>
                  <td class="px-3 py-3 text-center text-gray-400" colspan="7">No month selected.</td>
                </tr>
              </tbody>
            </table>
          </div>

          <div id="reconcile-detail-summary" class="grid gap-4 lg:grid-cols-4">
            <div class="rounded-lg border border-slate-200 bg-slate-50 p-4 shadow-sm">
              <div class="text-xs font-semibold text-gray-500 uppercase tracking-wide">Beginning Balance</div>
              <div id="reconcile-detail-beginning" class="mt-1 text-lg font-bold text-gray-800">$0.00</div>
            </div>
            <div class="rounded-lg border border-red-200 bg-red-50 p-4 shadow-sm">
              <div class="flex items-center justify-between text-xs font-semibold text-red-600 uppercase tracking-wide">
                <span>Payments</span>
                <span id="reconcile-detail-payments-count" class="text-[11px] font-medium text-red-500"></span>
              </div>
              <div id="reconcile-detail-payments" class="mt-1 text-lg font-bold text-red-600">-$0.00</div>
            </div>
            <div class="rounded-lg border border-emerald-200 bg-emerald-50 p-4 shadow-sm">
              <div class="flex items-center justify-between text-xs font-semibold text-emerald-600 uppercase tracking-wide">
                <span>Deposits</span>
                <span id="reconcile-detail-deposits-count" class="text-[11px] font-medium text-emerald-500"></span>
              </div>
              <div id="reconcile-detail-deposits" class="mt-1 text-lg font-bold text-emerald-600">$0.00</div>
            </div>
            <div class="rounded-lg border border-slate-200 bg-white p-4 shadow-sm">
              <div class="text-xs font-semibold text-gray-500 uppercase tracking-wide">Ending Balance</div>
              <div id="reconcile-detail-ending" class="mt-1 text-lg font-bold text-gray-800">$0.00</div>
            </div>
          </div>
        </div>
      </div>
    </section>
  </main>

  <!-- Toast / message container (non-blocking notifications) -->
  <div id="toast-container" class="fixed top-4 right-4 z-50 space-y-2"></div>

  <!-- COA modal (used for reclassification as well) -->
  <div id="coa-modal" class="fixed inset-0 hidden items-center justify-center bg-black bg-opacity-40 z-50">
    <div class="bg-white rounded-lg shadow-lg w-full max-w-lg p-4">
      <h3 class="font-bold mb-3">Choose Account</h3>
      <div class="mb-3">
        <select id="coa-select" class="w-full rounded-md border px-3 py-2"></select>
      </div>
      <div class="flex justify-end gap-2">
        <button id="coa-cancel" class="px-3 py-2 bg-slate-200 rounded">Cancel</button>
        <button id="coa-save" class="px-3 py-2 bg-emerald-600 text-white rounded">Apply</button>
      </div>
    </div>
  </div>

  <!-- Add COA modal -->
  <div id="add-coa-modal" class="fixed inset-0 hidden items-center justify-center bg-black bg-opacity-40 z-50">
    <div class="bg-white rounded-lg shadow-lg w-full max-w-md p-4">
      <h3 class="font-bold mb-3">Add Account</h3>
      <div class="space-y-2">
        <input id="new-account-name" class="w-full rounded-md border px-3 py-2" placeholder="Account Name" />
        <select id="new-account-type" class="w-full rounded-md border px-3 py-2">
          <option>Checking or savings</option>
          <option>Credit card account</option>
          <option>Cost of goods sold</option>
          <option>Fixed asset</option>
          <option>Capital / Equity</option>
          <option>Expense</option>
          <option>Income</option>
          <option>Other expense</option>
          <option>Other income</option>
          <option>Long term liability</option>
          <option>Other current liability</option>
        </select>
        <textarea id="new-account-desc" class="w-full rounded-md border px-3 py-2" placeholder="Description"></textarea>
      </div>
      <div class="flex justify-end gap-2 mt-3">
        <button id="add-coa-cancel" class="px-3 py-2 bg-slate-200 rounded">Cancel</button>
        <button id="add-coa-save" class="px-3 py-2 bg-indigo-600 text-white rounded">Save</button>
      </div>
    </div>
  </div>

  <!-- Paste Rules modal -->
  <div id="paste-rules-modal" class="fixed inset-0 hidden items-center justify-center bg-black bg-opacity-40 z-50">
    <div class="bg-white rounded-lg shadow-lg w-full max-w-2xl p-4">
      <h3 class="font-bold mb-3">Paste Multiple Rules</h3>
      <div class="space-y-3">
        <label class="text-sm">Apply this Transaction Type to all pasted rules:</label>
        <select id="paste-rules-type" class="w-full rounded-md border px-3 py-2">
          <option>Money Out</option>
          <option>Money In</option>
          <option>Both</option>
        </select>
        <label class="text-sm">Paste rules below (format: keyword,category):</label>
        <textarea id="paste-rules-text" class="w-full rounded-md border px-3 py-2" rows="8" placeholder="e.g. coffee,5-200 - Advertising\nuber,1-100 - Sales"></textarea>
        <div class="flex justify-end gap-2">
          <button id="paste-rules-cancel" class="px-3 py-2 bg-slate-200 rounded">Cancel</button>
          <button id="paste-rules-import" class="px-3 py-2 bg-indigo-600 text-white rounded">Import Rules</button>
        </div>
      </div>
    </div>
  </div>

  <!-- Confirm modal (non-blocking) -->
  <div id="confirm-modal" class="fixed inset-0 hidden items-center justify-center bg-black bg-opacity-40 z-50">
    <div class="bg-white rounded-lg shadow-lg w-full max-w-md p-4">
      <h3 class="font-bold mb-3">Confirm</h3>
      <div id="confirm-message" class="mb-4 text-sm text-gray-700"></div>
      <div class="flex justify-end gap-2">
        <button id="confirm-no" class="px-3 py-2 bg-slate-200 rounded">Cancel</button>
        <button id="confirm-yes" class="px-3 py-2 bg-amber-500 text-white rounded">OK</button>
      </div>
    </div>
  </div>

  <!-- Server project picker modal -->
  <div id="server-project-modal" class="fixed inset-0 hidden items-center justify-center bg-black bg-opacity-40 z-50">
    <div class="bg-white rounded-lg shadow-lg w-full max-w-lg p-4 space-y-3">
      <div class="flex items-center justify-between">
        <h3 class="font-bold text-lg">Load Project from Server</h3>
        <button id="server-project-close" class="text-sm text-gray-500 hover:text-gray-700">&times;</button>
      </div>
      <p class="text-sm text-gray-600">Select a saved snapshot below to load it instantly.</p>
      <div id="server-project-list" class="max-h-72 overflow-y-auto space-y-2"></div>
      <div class="flex justify-end gap-2 pt-2">
        <button id="server-project-cancel" class="px-3 py-2 rounded-md bg-slate-200 text-sm font-semibold">Cancel</button>
      </div>
    </div>
  </div>

  <!-- Transaction edit/add modal -->
  <div id="transaction-modal" class="fixed inset-0 hidden items-center justify-center bg-black bg-opacity-40 z-50">
    <div class="bg-white rounded-lg shadow-lg w-full max-w-md p-4 space-y-3">
      <div class="flex items-center justify-between">
        <h3 id="transaction-modal-title" class="font-bold text-lg">Edit Transaction</h3>
        <button id="transaction-modal-close" class="text-sm text-gray-500 hover:text-gray-700">&times;</button>
      </div>
      <div class="space-y-3">
        <div>
          <label for="transaction-date" class="block text-sm font-medium text-gray-700 mb-1">Date</label>
          <input id="transaction-date" type="date" class="w-full rounded-md border border-slate-300 px-3 py-2 focus:outline-none focus:ring-2 focus:ring-indigo-500" />
        </div>
        <div>
          <label for="transaction-description" class="block text-sm font-medium text-gray-700 mb-1">Description</label>
          <input id="transaction-description" type="text" class="w-full rounded-md border border-slate-300 px-3 py-2 focus:outline-none focus:ring-2 focus:ring-indigo-500" placeholder="Description" />
        </div>
        <div>
          <label for="transaction-amount" class="block text-sm font-medium text-gray-700 mb-1">Amount</label>
          <input id="transaction-amount" type="number" step="0.01" class="w-full rounded-md border border-slate-300 px-3 py-2 focus:outline-none focus:ring-2 focus:ring-indigo-500" placeholder="Use negative for payments" />
          <p class="mt-1 text-xs text-gray-500">Enter deposits as positive amounts and payments as negative amounts.</p>
        </div>
      </div>
      <div class="flex justify-end gap-2 pt-2">
        <button id="transaction-modal-cancel" class="px-3 py-2 rounded-md bg-slate-200 text-sm font-semibold">Cancel</button>
        <button id="transaction-modal-save" class="px-3 py-2 rounded-md bg-emerald-600 text-white text-sm font-semibold">Save</button>
      </div>
    </div>
  </div>

  <script>
  // === State ===
const state = {
    transactions: [],
    coaTable: [],
    rules: [],
    sort: { tab: '', column: null, direction: 'asc' },
    reportView: 'pl',
    selectedTxIndexes: new Set(),
    anchorIndex: null,
    anchorContext: null,
    unassignedDisplayOrder: [],
    assignedDisplayOrder: [],
    selectionContext: null,
    dragSelecting: false,
    dragStartOrder: null,
    dragMoved: false,
    dragJustFinished: false,
    reconcileView: 'summary',
    reconcileMonthlyData: [],
    selectedReconcileMonthKey: null,
    selectedMonthlyTxIndexes: new Set(),
    transactionModalMode: null,
    transactionModalIndex: null,
    transactionModalMonthKey: null,
    beginningBalance: 0,
    statementBalance: 0,
    coaSort: { column: null, direction: 'asc' },
    loadedTransactionFingerprints: new Set()
  };

  // === Utilities ===
  function formatCurrency(n) {
    const v = Number(n) || 0;
    return v.toLocaleString(undefined, { style: 'currency', currency: 'USD' });
  }

  function inferAccountType(name) {
    const n = (name||'').toLowerCase();
    if (n.includes('bank') || n.includes('checking') || n.includes('savings')) return ['BANK','Checking or savings'];
      if (n.includes('draw')) return ['EQUITY', 'Capital / Equity'];
    if (n.includes('card') || n.includes('credit')) return ['CCARD','Credit card account'];
    if (n.includes('cost of goods sold') || n.includes('cogs')) return ['COGS','Cost of goods sold'];
    if (n.includes('fixed asset') || n.includes('fixed assets')) return ['FIXASSET','Fixed asset'];
    if (n.includes('equity') || n.includes("owner's draw") || n.includes("owner's contribution") || n.includes('capital')) return ['EQUITY','Capital / Equity'];
    if (n.includes('income') || n.includes('sales') || n.includes('revenue')) return ['INC','Income'];
    if (n.includes('liability') || n.includes('loan') || n.includes('note payable')) return ['LTLIAB','Long term liability'];
    if (n.includes('payable') || n.includes('due')) return ['OCLIAB','Other current liability'];
    if (n.includes('expense') || n.includes('fee') || n.includes('rent') || n.includes('supplies') || n.includes('fuel') || n.includes('insurance') || n.includes('advertising') || n.includes('meals') || n.includes('office')) return ['EXP','Expense'];
    return ['EXP','Expense'];
  }

  function refreshAllDropdowns() {
    const select = document.getElementById('coa-select');
    if (!select) return;
    select.innerHTML = '';
    const placeholder = document.createElement('option');
    placeholder.value = '';
    placeholder.textContent = '-- Select Account --';
    select.appendChild(placeholder);
    state.coaTable.forEach(a => {
      const opt = document.createElement('option');
      opt.value = a['Account Name'];
      opt.textContent = a['Account Name'];
      select.appendChild(opt);
    });

    // Update transaction dropdowns if tables are visible
    renderUnassigned();
    renderAssigned();
  }

  function setCurrentFileLabel(text) {
    const label = document.getElementById('current-file-label');
    if (!label) return;
    const value = (text || '').trim();
    if (value) {
      label.textContent = value;
      label.classList.remove('hidden');
    } else {
      label.textContent = '';
      label.classList.add('hidden');
    }
  }

  function ensureScheduleCCategoryField(row) {
    if (!row || typeof row !== 'object') return row;
    const hasKey = Object.prototype.hasOwnProperty.call(row, 'Schedule C Category');
    if (!hasKey || row['Schedule C Category'] === undefined || row['Schedule C Category'] === null) {
      row['Schedule C Category'] = '';
    }
    return row;
  }

  function normalizeFingerprintValue(value) {
    if (value === null || value === undefined) return '';
    if (value instanceof Date) return value.toISOString();
    if (typeof value === 'number' && !Number.isFinite(value)) return '';
    return typeof value === 'string' ? value : String(value);
  }

  function fingerprintTransactions(rows) {
    if (!Array.isArray(rows) || rows.length === 0) return '';
    const perRow = rows.map(row => {
      const keys = Object.keys(row || {}).sort();
      return keys.map(key => `${key}:${normalizeFingerprintValue(row[key])}`).join('|');
    });
    return perRow.join('||');
  }

  function createProjectSnapshot() {
    const snapshot = {
      meta: {
        exportedAt: new Date().toISOString(),
        app: 'BankTransactionCategorizer',
        version: 1
      },
      data: {
        transactions: Array.isArray(state.transactions) ? state.transactions : [],
        coaTable: Array.isArray(state.coaTable) ? state.coaTable : [],
        rules: Array.isArray(state.rules) ? state.rules : [],
        sort: state.sort && typeof state.sort === 'object' ? state.sort : { tab: '', column: null, direction: 'asc' },
        reportView: state.reportView || 'pl',
        beginningBalance: Number(state.beginningBalance) || 0,
        statementBalance: Number(state.statementBalance) || 0,
        reconcileView: state.reconcileView || 'summary',
        selectedReconcileMonthKey: state.selectedReconcileMonthKey || null,
        assignedFilter: state.assignedFilter || null,
        loadedTransactionFingerprints: Array.from(state.loadedTransactionFingerprints || [])
      }
    };
    return snapshot;
  }

  async function applyAccountRename(account, newName) {
    if (!account) return { status: 'failed' };
    const oldNameRaw = account['Account Name'] ?? '';
    const oldName = oldNameRaw.toString().trim();
    const updatedName = (newName ?? '').toString().trim();
    if (!updatedName) {
      showMessage('Account name cannot be empty.', 'warning', 2500);
      return { status: 'failed' };
    }
    const lowerUpdated = updatedName.toLowerCase();
    const lowerOld = oldName.toLowerCase();
    const duplicateAccount = state.coaTable.find(acc => acc !== account && (acc['Account Name'] || '').toString().trim().toLowerCase() === lowerUpdated);
    if (duplicateAccount) {
      const confirmed = await showConfirm(`An account named "${updatedName}" already exists. Merge these accounts?`);
      if (!confirmed) {
        showMessage('Merge cancelled; account name unchanged.', 'info', 2500);
        return { status: 'cancelled' };
      }

      const targetName = (duplicateAccount['Account Name'] ?? updatedName).toString().trim() || updatedName;

      state.transactions.forEach(tx => {
        if (!tx) return;
        const currentRaw = tx['Schedule C Category'];
        const trimmedCurrent = (currentRaw ?? '').toString().trim().toLowerCase();
        if (trimmedCurrent === lowerOld) {
          tx['Schedule C Category'] = targetName;
        }
      });

      if (Array.isArray(state.rules)) {
        state.rules.forEach(rule => {
          if (!rule) return;
          if (typeof rule.category === 'string' && rule.category.trim().toLowerCase() === lowerOld) {
            rule.category = targetName;
          }
          if (typeof rule.Category === 'string' && rule.Category.trim().toLowerCase() === lowerOld) {
            rule.Category = targetName;
          }
        });
      }

      if (state.assignedFilter && state.assignedFilter.trim().toLowerCase() === lowerOld) {
        state.assignedFilter = targetName;
      }

      if ((!duplicateAccount['Account Type'] || !duplicateAccount['Account Type'].toString().trim()) && account['Account Type']) {
        duplicateAccount['Account Type'] = account['Account Type'];
      }
      if ((!duplicateAccount['Description'] || !duplicateAccount['Description'].toString().trim()) && account['Description']) {
        duplicateAccount['Description'] = account['Description'];
      }

      const idx = state.coaTable.indexOf(account);
      if (idx !== -1) {
        state.coaTable.splice(idx, 1);
      }

      showMessage(`Merged account into "${targetName}".`, 'success', 3000);
      return { status: 'merged', name: targetName };
    }

    account['Account Name'] = updatedName;

    state.transactions.forEach(tx => {
      if (!tx) return;
      const currentRaw = tx['Schedule C Category'];
      const trimmedCurrent = (currentRaw ?? '').toString().trim().toLowerCase();
      if (trimmedCurrent === lowerOld) {
        tx['Schedule C Category'] = updatedName;
      }
    });

    if (Array.isArray(state.rules)) {
      state.rules.forEach(rule => {
        if (!rule) return;
        if (typeof rule.category === 'string' && rule.category.trim().toLowerCase() === lowerOld) {
          rule.category = updatedName;
        }
        if (typeof rule.Category === 'string' && rule.Category.trim().toLowerCase() === lowerOld) {
          rule.Category = updatedName;
        }
      });
    }

    if (state.assignedFilter && state.assignedFilter.trim().toLowerCase() === lowerOld) {
    state.assignedFilter = updatedName;
  }

  return { status: 'renamed', name: updatedName };
}

  function updateSelectionUI() {
    try {
      const selected = state.selectedTxIndexes;
  document.querySelectorAll('#unassigned-body tr').forEach(tr => {
    const idx = Number(tr.dataset.idx);
    const isSelected = !Number.isNaN(idx) && selected.has(idx);
    tr.classList.toggle('bg-indigo-50', isSelected);
    const cb = tr.querySelector('input[type="checkbox"]');
    if (cb) cb.checked = isSelected;
  });
      document.querySelectorAll('#assigned-body tr').forEach(tr => {
        const idx = Number(tr.dataset.idx);
        const isSelected = !Number.isNaN(idx) && selected.has(idx);
        tr.classList.toggle('bg-indigo-50', isSelected);
        const cb = tr.querySelector('input[type="checkbox"]');
        if (cb) cb.checked = isSelected;
      });
      const reclassBtn = document.getElementById('reclassify-button');
      if (reclassBtn) reclassBtn.disabled = selected.size === 0;
      const copyBtn = document.getElementById('copy-selection-button');
      if (copyBtn) copyBtn.disabled = selected.size === 0;
      const copyAssignedBtn = document.getElementById('copy-selection-assigned');
      if (copyAssignedBtn) copyAssignedBtn.disabled = selected.size === 0;
      const assignedBtn = document.getElementById('assigned-reclassify-button');
      if (assignedBtn) assignedBtn.disabled = selected.size === 0;
      const assignedSelectAll = document.getElementById('assigned-select-all');
      if (assignedSelectAll) {
        const visibleIdx = Array.from(document.querySelectorAll('#assigned-body tr')).map(tr => Number(tr.dataset.idx)).filter(idx => !Number.isNaN(idx));
        const selectedCount = visibleIdx.filter(idx => selected.has(idx)).length;
        assignedSelectAll.checked = visibleIdx.length > 0 && selectedCount === visibleIdx.length;
        assignedSelectAll.indeterminate = selectedCount > 0 && selectedCount < visibleIdx.length;
      }
      const unassignedSelectAll = document.getElementById('unassigned-select-all');
      if (unassignedSelectAll) {
        const visibleIdx = Array.isArray(state.unassignedDisplayOrder) ? state.unassignedDisplayOrder.filter(idx => Number.isInteger(idx)) : [];
        const selectedCount = visibleIdx.filter(idx => selected.has(idx)).length;
        unassignedSelectAll.checked = visibleIdx.length > 0 && selectedCount === visibleIdx.length;
        unassignedSelectAll.indeterminate = visibleIdx.length > 0 && selectedCount > 0 && selectedCount < visibleIdx.length;
      }
    } catch (_err) {
      // best-effort UI sync; ignore errors caused by transient re-renders
    }
  }

  function applyDragSelection(targetOrder) {
    if (!Array.isArray(state.unassignedDisplayOrder) || state.unassignedDisplayOrder.length === 0) return;
    const startOrder = state.dragStartOrder;
    if (startOrder === null || startOrder === undefined) return;
    const minOrder = Math.max(0, Math.min(startOrder, targetOrder));
    const maxOrder = Math.min(state.unassignedDisplayOrder.length - 1, Math.max(startOrder, targetOrder));
    const set = state.selectedTxIndexes;
    set.clear();
    for (let order = minOrder; order <= maxOrder; order++) {
      const idx = state.unassignedDisplayOrder[order];
      if (Number.isInteger(idx)) set.add(idx);
    }
    const anchorOrder = Math.max(0, Math.min(state.unassignedDisplayOrder.length - 1, startOrder));
    state.anchorIndex = state.unassignedDisplayOrder[anchorOrder] ?? null;
    state.anchorContext = 'unassigned';
    state.selectionContext = 'unassigned';
    state.dragMoved = state.dragMoved || (minOrder !== maxOrder);
    updateSelectionUI();
  }

  function endDragSelection() {
    if (!state.dragSelecting) return;
    document.removeEventListener('mouseup', endDragSelection);
    state.dragSelecting = false;
    const hadMovement = state.dragMoved;
    state.dragStartOrder = null;
    state.dragMoved = false;
    if (hadMovement) {
      state.dragJustFinished = true;
      setTimeout(() => { state.dragJustFinished = false; }, 0);
    }
  }

  function startDragSelection(order) {
    state.dragSelecting = true;
    state.dragStartOrder = order;
    state.dragMoved = false;
    state.dragJustFinished = false;
    state.selectionContext = 'unassigned';
    applyDragSelection(order);
    document.addEventListener('mouseup', endDragSelection);
  }

  function onUnassignedRowMouseDown(ev, order) {
    if (ev.button !== 0 || ev.shiftKey || ev.ctrlKey || ev.metaKey) return;
    const tag = (ev.target?.tagName || '').toUpperCase();
    if (tag === 'SELECT' || tag === 'INPUT' || tag === 'BUTTON' || tag === 'TEXTAREA' || tag === 'LABEL' || tag === 'OPTION') return;
    startDragSelection(order);
    ev.preventDefault();
  }

  function onUnassignedRowMouseEnter(ev, order) {
    if (!state.dragSelecting) return;
    if (!(ev.buttons & 1)) {
      endDragSelection();
      return;
    }
    applyDragSelection(order);
  }

  // Non-blocking toast messages (replace alert())
  function showMessage(msg, type='info', timeout=3000) {
    try {
      const container = document.getElementById('toast-container');
      if (!container) return;
      const el = document.createElement('div');
      const bg = type === 'error' ? 'bg-red-600 text-white' : type === 'warn' || type === 'warning' ? 'bg-amber-500 text-white' : 'bg-slate-800 text-white';
      el.className = `${bg} px-4 py-2 rounded shadow-lg max-w-xs break-words`;
      el.textContent = msg;
      container.appendChild(el);
      setTimeout(() => { el.classList.add('opacity-0'); setTimeout(()=>el.remove(),300); }, timeout);
    } catch (e) { console.error('showMessage error', e); }
  }

  // Custom confirm modal to replace native confirm()
  function showConfirm(message) {
    return new Promise((resolve) => {
      const modal = document.getElementById('confirm-modal');
      const msgEl = document.getElementById('confirm-message');
      const yes = document.getElementById('confirm-yes');
      const no = document.getElementById('confirm-no');
      if (!modal || !msgEl || !yes || !no) {
        // fallback to window.confirm if DOM not ready
        resolve(window.confirm(message));
        return;
      }
      msgEl.textContent = message;
      modal.classList.remove('hidden'); modal.style.display = 'flex';
      const cleanup = () => { yes.removeEventListener('click', onYes); no.removeEventListener('click', onNo); modal.classList.add('hidden'); modal.style.display='none'; };
      const onYes = () => { cleanup(); resolve(true); };
      const onNo = () => { cleanup(); resolve(false); };
      yes.addEventListener('click', onYes); no.addEventListener('click', onNo);
    });
  }

  function showServerProjectPicker(files) {
    return new Promise((resolve) => {
      const modal = document.getElementById('server-project-modal');
      const listEl = document.getElementById('server-project-list');
      const cancelBtn = document.getElementById('server-project-cancel');
      const closeBtn = document.getElementById('server-project-close');
      if (!modal || !listEl || !cancelBtn || !closeBtn) {
        resolve(null);
        return;
      }

      const cleanup = () => {
        cancelBtn.removeEventListener('click', onCancel);
        closeBtn.removeEventListener('click', onCancel);
        modal.classList.add('hidden');
        modal.style.display = 'none';
        while (listEl.firstChild) listEl.removeChild(listEl.firstChild);
      };

      const onCancel = () => {
        cleanup();
        resolve(null);
      };

      listEl.innerHTML = '';
      files.forEach(file => {
        const btn = document.createElement('button');
        btn.type = 'button';
        btn.className = 'w-full text-left px-3 py-2 rounded-md border border-slate-200 bg-white text-sm font-semibold text-slate-700 shadow-sm hover:bg-indigo-50';
        btn.textContent = file;
        btn.addEventListener('click', () => {
          cleanup();
          resolve(file);
        });
        listEl.appendChild(btn);
      });

      cancelBtn.addEventListener('click', onCancel);
      closeBtn.addEventListener('click', onCancel);
      modal.classList.remove('hidden');
      modal.style.display = 'flex';
    });
  }

  // Robust amount parser: handles numbers, strings with $ and commas, and parentheses for negatives
  function parseAmount(v) {
    if (v === null || v === undefined) return 0;
    if (typeof v === 'number') return v;
    let s = String(v).trim();
    if (s === '') return 0;
    // detect parentheses as negative: (1,234.56)
    let negative = false;
    if (/^\(.+\)$/.test(s)) {
      negative = true;
      s = s.replace(/^\(|\)$/g, '');
    }
    // remove currency symbols, spaces, and commas
    s = s.replace(/[^0-9.\-]/g, '');
    const n = parseFloat(s);
    if (Number.isNaN(n)) return 0;
    return negative ? -Math.abs(n) : n;
  }

  function sanitizeIifValue(value) {
    return String(value ?? '')
      .replace(/[\r\n]+/g, ' ')
      .replace(/\t/g, ' ')
      .trim();
  }

  function formatDateForIif(rawValue) {
    if (rawValue === null || rawValue === undefined || rawValue === '') return '';
    const pad = num => String(num).padStart(2, '0');
    const toFormattedString = dateObj => {
      if (Number.isNaN(dateObj.getTime())) return '';
      return `${pad(dateObj.getMonth() + 1)}/${pad(dateObj.getDate())}/${dateObj.getFullYear()}`;
    };
    if (rawValue instanceof Date) return toFormattedString(rawValue);

    const numericValue = typeof rawValue === 'number' ? rawValue : Number(rawValue);
    if (Number.isFinite(numericValue) && String(rawValue).trim() !== '') {
      if (typeof XLSX !== 'undefined' && XLSX.SSF && typeof XLSX.SSF.parse_date_code === 'function') {
        const parsed = XLSX.SSF.parse_date_code(numericValue);
        if (parsed && parsed.y) return `${pad(parsed.m)}/${pad(parsed.d)}/${parsed.y}`;
      }
      const excelEpoch = new Date(Date.UTC(1899, 11, 30));
      const dateFromSerial = new Date(excelEpoch.getTime() + numericValue * 86400000);
      const formatted = toFormattedString(dateFromSerial);
      if (formatted) return formatted;
    }

    const stringValue = String(rawValue).trim();
    if (!stringValue) return '';

    const isoMatch = stringValue.match(/^(\d{4})-(\d{2})-(\d{2})/);
    if (isoMatch) {
      const [, year, month, day] = isoMatch;
      return `${month}/${day}/${year}`;
    }
    const slashMatch = stringValue.match(/^(\d{1,2})[\/\-](\d{1,2})[\/\-](\d{2,4})$/);
    if (slashMatch) {
      let [, month, day, year] = slashMatch;
      month = pad(month);
      day = pad(day);
      if (year.length === 2) year = `20${year}`;
      else if (year.length === 3) year = `2${year}`;
      return `${month}/${day}/${year}`;
    }

    const parsedDate = new Date(stringValue);
    const formatted = toFormattedString(parsedDate);
    return formatted || stringValue;
  }

  function formatDateDisplay(rawValue) {
    const formatted = formatDateForIif(rawValue);
    if (!formatted) return '';
    return formatted;
  }

  function getDisplayValueForColumn(header, value) {
    const key = (header || '').toString().toLowerCase();
    if (key.includes('date')) {
      const formattedDate = formatDateDisplay(value);
      if (formattedDate) return formattedDate;
    }
    if (value === null || value === undefined) return '';
    return value;
  }

  function normalizeColumnKey(key) {
    if (key === null || key === undefined) return '';
    return key.toString().toLowerCase().replace(/[^a-z0-9]+/g, ' ').trim();
  }

  function mapAccountTypeToIifType(account) {
    if (!account) return '';
    const typeMap = {
      'checking or savings': 'BANK',
      'checking': 'BANK',
      'savings': 'BANK',
      'credit card account': 'CCARD',
      'cost of goods sold': 'COGS',
      'fixed asset': 'FIXASSET',
      'capital / equity': 'EQUITY',
      'equity': 'EQUITY',
      'expense': 'EXP',
      'other expense': 'OEXP',
      'income': 'INC',
      'other income': 'OINC',
      'long term liability': 'LTLIAB',
      'other current liability': 'OCLIAB'
    };
    const rawType = (account['Account Type'] || '').toString().trim().toLowerCase();
    if (rawType && typeMap[rawType]) return typeMap[rawType];
    const [code] = inferAccountType(account['Account Name'] || '');
    return code || '';
  }

  function classifyAccountType(accountType, accountName='') {
    const type = (accountType || '').toString().trim().toLowerCase();
    const name = (accountName || '').toString().trim().toLowerCase();
    const includesType = value => type.includes(value);
    const includesName = value => name.includes(value);

    if (includesType('expense') || includesType('cogs')) return 'expense';
    if (includesType('income') || includesType('revenue') || includesType('sales')) return 'income';
    if (includesType('liability') || includesType('payable') || includesType('loan') || includesType('credit')) return 'liability';
    if (includesType('equity') || includesType('capital') || includesType('retained')) return 'equity';
    if (includesType('asset') || includesType('cash') || includesType('bank')) return 'asset';

    if (includesName('expense') || includesName('fees') || includesName('cogs')) return 'expense';
    if (includesName('income') || includesName('revenue') || includesName('sales')) return 'income';
    if (includesName('liability') || includesName('payable') || includesName('loan') || includesName('credit') || includesName('card') || includesName('mortgage')) return 'liability';
    if (includesName('equity') || includesName('capital') || includesName('retained') || includesName("owner")) return 'equity';
    if (includesName('asset') || includesName('cash') || includesName('bank') || includesName('checking') || includesName('savings')) return 'asset';
    if (includesName('receivable')) return 'asset';

    const [code] = inferAccountType(accountName || accountType || '');
    if (code === 'BANK') return 'asset';
    if (code === 'LTLIAB' || code === 'OCLIAB' || code === 'CCARD') return 'liability';
    if (code === 'EQUITY') return 'equity';
    if (code === 'INC') return 'income';
    if (code === 'COGS' || code === 'EXP' || code === 'OEXP') return 'expense';
    return 'other';
  }

  function resolveFieldValue(tx, fieldName) {
    if (!tx || !fieldName) return '';
    const target = fieldName.toLowerCase().trim();
    let direct = tx[fieldName];
    if (direct !== undefined && direct !== null && direct !== '') return direct;
    for (const key of Object.keys(tx)) {
      if (!key) continue;
      if (key.toLowerCase().trim() === target) return tx[key];
    }
    return '';
  }

  function buildJournalMemo(tx) {
    const candidates = [
      resolveFieldValue(tx, 'Transactions Description'),
      resolveFieldValue(tx, 'Transaction Description'),
      resolveFieldValue(tx, 'Description'),
      resolveFieldValue(tx, 'Memo'),
      resolveFieldValue(tx, 'Payee'),
      resolveFieldValue(tx, 'Details')
    ];
    const parts = [];
    const seen = new Set();
    candidates.forEach(raw => {
      const sanitized = sanitizeIifValue(raw);
      if (!sanitized) return;
      const key = sanitized.toLowerCase();
      if (seen.has(key)) return;
      seen.add(key);
      parts.push(sanitized);
    });
    return parts.join(' | ');
  }

  // Add accounts referenced by rules into the COA if missing
  function addAccountsFromRules() {
    if (!state.rules || state.rules.length === 0) return 0;
    const existing = new Set(state.coaTable.map(a => (a['Account Name'] || '').toString().trim().toLowerCase()));
    let added = 0;
    state.rules.forEach(r => {
      const category = (r.category || r.Category || r[1] || '').toString().trim();
      if (!category) return;
      const key = category.toLowerCase();
      if (!existing.has(key)) {
        const acctType = inferAccountType(category)[1];
        state.coaTable.push({ 'Account Name': category, 'Account Type': acctType, 'Description': 'Added from rules' });
        existing.add(key);
        added++;
      }
    });
    if (added > 0) { renderCoa(); refreshAllDropdowns(); updateReports(); }
    return added;
  }

  // Applies state.rules to unassigned transactions. Supports simple substring match on payee/description,
  // optional direction ("in"/"out"), and numeric filters when provided in JSON.
  function applyRules() {
    if (!state.rules || state.rules.length === 0) return 0;

    const amtTokenRe = /\{AMT\s*(<=|>=|<|>|==)\s*([0-9]+(?:\.[0-9]+)?)\}/i;
    const compiled = [];
    state.rules.forEach(r => {
      const raw = (r.payee || r.match || r.pattern || '').toString();
      let pattern = raw;
      let amtCond = null;
      const m = amtTokenRe.exec(raw);
      if (m) {
        const op = m[1]; const val = parseFloat(m[2]);
        if (!Number.isNaN(val)) {
          if (op === '<=') amtCond = x => x <= val;
          else if (op === '>=') amtCond = x => x >= val;
          else if (op === '<') amtCond = x => x < val;
          else if (op === '>') amtCond = x => x > val;
          else amtCond = x => Math.abs(x - val) < 1e-9;
        }
        pattern = pattern.replace(m[0], '').trim();
      }

      let regex = null;
      if (pattern) {
        try { regex = new RegExp(pattern, 'i'); } catch (err) { regex = null; }
      }

      compiled.push({ rawPattern: raw, pattern, regex, category: r.category || r.Category || r.cat || '', direction: (r.direction || r.type || r['Transaction Type'] || '').toString(), amtCond });
    });

    let applied = 0;
    const matchedTxs = [];

    state.transactions.forEach((tx, idx) => {
      if (!tx) return;
      if (tx['Schedule C Category']) return; // only unassigned
      const desc = (tx.Description || tx.description || tx.Payee || '').toString();
      const descLower = desc.toLowerCase();
      const amount = parseAmount(tx.Amount ?? tx.amount ?? 0);

      for (const rule of compiled) {
        if (!rule.pattern) continue;
        let matched = false;
        if (rule.regex) {
          try { if (rule.regex.test(desc)) matched = true; } catch (e) { matched = false; }
        } else {
          if (descLower.includes(rule.pattern.toLowerCase())) matched = true;
        }
        if (!matched) continue;

        const dir = (rule.direction || '').toString().toLowerCase();
        if (dir) {
          if ((dir.includes('money in') || dir.includes('in')) && amount <= 0) continue;
          if ((dir.includes('money out') || dir.includes('out')) && amount >= 0) continue;
        }

        if (rule.amtCond && !rule.amtCond(Math.abs(amount))) continue;

        if (rule.category) {
          tx['Schedule C Category'] = rule.category;
          applied++; matchedTxs.push({ desc: desc, amount: amount, category: rule.category });
          break;
        }
      }
    });

    return applied;
  }

  // Analyze rules without applying them; returns diagnostic info
  function analyzeRules() {
    const diagnostics = { totalRules: state.rules ? state.rules.length : 0, totalTransactions: state.transactions.length, perRule: [] };
    if (!state.rules || state.rules.length === 0) return diagnostics;
    state.rules.forEach(rule => {
      const pattern = (rule.payee || rule.match || rule.pattern || '').toString().toLowerCase().trim();
      let patternMatches = 0; let dirFails = 0; let amountFails = 0; let wouldApply = 0; const samples = [];
      state.transactions.forEach(tx => {
        if (!tx) return; if (tx['Schedule C Category']) return;
        const payee = ((tx.Payee || tx.Description || '') + '').toLowerCase();
        const amount = parseAmount(tx.Amount ?? tx.amount ?? 0);
        if (!pattern) return; if (!payee.includes(pattern)) return; patternMatches++;
        let dirOk = true;
        if (rule.direction) {
          const dir = rule.direction.toString().toLowerCase();
          if ((dir.includes('deposit') || dir.includes('in')) && amount < 0) dirOk = false;
          if ((dir.includes('withdraw') || dir.includes('out')) && amount >= 0) dirOk = false;
        }
        if (!dirOk) { dirFails++; samples.push({ tx, reason: 'direction' }); return; }
        let amtOk = true;
        if (rule.amount !== undefined && rule.amount !== null && rule.amount !== '') {
          const want = Number(rule.amount); if (Number.isFinite(want) && Math.abs(amount) !== Math.abs(want)) amtOk = false;
        }
        if (rule.amountMin !== undefined && rule.amountMin !== null && rule.amountMin !== '') {
          const min = Number(rule.amountMin); if (Number.isFinite(min) && Math.abs(amount) < Math.abs(min)) amtOk = false;
        }
        if (rule.amountMax !== undefined && rule.amountMax !== null && rule.amountMax !== '') {
          const max = Number(rule.amountMax); if (Number.isFinite(max) && Math.abs(amount) > Math.abs(max)) amtOk = false;
        }
        if (!amtOk) { amountFails++; samples.push({ tx, reason: 'amount' }); return; }
        if (rule.category) { wouldApply++; samples.push({ tx, reason: 'apply' }); }
      });
      diagnostics.perRule.push({ rule, pattern, patternMatches, dirFails, amountFails, wouldApply, samples });
    });
    return diagnostics;
  }

  function renderRulesAnalysis(diag) {
    // suppressed UI for now  diagnostics intentionally silent
  }

  // Remove any 'Applied Rule' metadata from transactions (so it doesn't become a visible column)
  function clearAppliedRuleMetadata() {
    if (!state.transactions || state.transactions.length === 0) return;
    state.transactions.forEach(tx => {
      if (tx && Object.prototype.hasOwnProperty.call(tx, 'Applied Rule')) delete tx['Applied Rule'];
    });
  }

  // Paste Rules modal handlers
  document.getElementById('bulk-apply-gpt').addEventListener('click', () => {
    const modal = document.getElementById('paste-rules-modal');
    modal.classList.remove('hidden'); modal.style.display = 'flex';
    document.getElementById('paste-rules-text').value = '';
    document.getElementById('paste-rules-type').value = 'Money Out';
  });

  document.getElementById('paste-rules-cancel').addEventListener('click', () => {
    const modal = document.getElementById('paste-rules-modal'); modal.classList.add('hidden'); modal.style.display='none';
  });

  document.getElementById('paste-rules-import').addEventListener('click', () => {
    const text = document.getElementById('paste-rules-text').value || '';
    const type = document.getElementById('paste-rules-type').value || 'Both';
    const lines = text.split(/\r?\n/).map(l => l.trim()).filter(Boolean);
    let added = 0;
    lines.forEach(l => {
      const parts = l.split(',').map(p => p.trim());
      if (parts.length >= 2) {
        const keyword = parts[0];
        const category = parts[1];
        state.rules.push({ payee: keyword, category: category, direction: type });
        added++;
      }
    });
    if (added > 0) {
      addAccountsFromRules();
      const applied = applyRules();
      clearAppliedRuleMetadata();
      updateReports(); renderUnassigned(); renderAssigned(); refreshAllDropdowns();
      showMessage(`Imported ${added} rules${applied>0?` and applied ${applied}`:''}`, 'info', 4000);
    }
    const modal = document.getElementById('paste-rules-modal'); modal.classList.add('hidden'); modal.style.display='none';
  });

  // === File loaders ===
  const txInput = document.getElementById('tx-input');
  if (txInput) txInput.addEventListener('change', handleTransactionFiles);
  const projectInput = document.getElementById('project-load-input');
  if (projectInput) projectInput.addEventListener('change', handleProjectLoad);
  const exportProjectButton = document.getElementById('export-project-button');
  if (exportProjectButton) exportProjectButton.addEventListener('click', exportProjectSnapshot);
  const saveProjectServerButton = document.getElementById('save-project-server-button');
  if (saveProjectServerButton) saveProjectServerButton.addEventListener('click', saveProjectToServer);
  const loadProjectServerButton = document.getElementById('load-project-server-button');
  if (loadProjectServerButton) loadProjectServerButton.addEventListener('click', loadProjectFromServer);

  async function handleTransactionFiles(e) {
    const files = Array.from(e.target.files || []);
    if (files.length === 0) return;
    let appendedTotal = 0;
    let skippedDuplicates = 0;

    for (const file of files) {
      try {
        const result = await importTransactionsFromFile(file);
        appendedTotal += result.appended || 0;
        if (result.skippedDuplicate) skippedDuplicates += 1;
      } catch (err) {
        console.error('Failed to load transactions from file', file?.name, err);
        const reason = (err && err.message) ? ` ${err.message}` : ' Unable to read the file.';
        showMessage(`Failed to load "${file?.name}".${reason}`, 'error', 4000);
      }
    }

    e.target.value = '';

    if (appendedTotal > 0) {
      const fileNames = files.map(f => f.name).filter(Boolean);
      if (fileNames.length > 0) {
        setCurrentFileLabel(fileNames.join(', '));
      }

      state.selectedTxIndexes.clear();
      state.anchorIndex = null;
      state.anchorContext = null;
      state.selectionContext = null;

      if (state.rules && state.rules.length > 0) {
        addAccountsFromRules();
        const applied = applyRules();
        clearAppliedRuleMetadata();
        if (applied > 0) {
          showMessage(`Applied ${applied} rule-based classifications`, 'info', 3000);
        }
      }

      renderUnassigned();
      renderAssigned();
      updateReports();
      refreshAllDropdowns();
      const fileLabel = files.length === 1 ? 'file' : 'files';
      showMessage(
        `Added ${appendedTotal} transaction${appendedTotal === 1 ? '' : 's'} from ${files.length} ${fileLabel}.`,
        'success',
        3500
      );
    } else if (skippedDuplicates > 0) {
      showMessage('Selected file(s) matched transactions already loaded. Nothing was added.', 'warning', 3500);
    }
  }

  function exportProjectSnapshot() {
    try {
      const snapshot = createProjectSnapshot();
      const json = JSON.stringify(snapshot, null, 2);
      const stamp = new Date().toISOString().replace(/[:.]/g, '-');
      triggerDownload(`ProjectBackup_${stamp}.json`, json, 'application/json');
      showMessage('Project exported.', 'success', 3000);
    } catch (err) {
      console.error('exportProjectSnapshot error', err);
      showMessage('Unable to export project.', 'error', 4000);
    }
  }

  async function saveProjectToServer() {
    const rawName = prompt('Enter a project name to save on the server (letters, numbers, dash, underscore).');
    if (rawName === null) return;
    const trimmed = (rawName || '').trim();
    if (!trimmed) {
      showMessage('Server project name is required.', 'warning', 3000);
      return;
    }
    const safeName = trimmed.replace(/[^a-z0-9_\-]/gi, '_');
    if (!safeName) {
      showMessage('Server project name is invalid.', 'error', 3500);
      return;
    }
    try {
      const snapshot = createProjectSnapshot();
      const response = await fetch('/save_project', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ filename: safeName, content: snapshot })
      });
      if (!response.ok) {
        const text = await response.text();
        throw new Error(text || 'save_project failed');
      }
      const result = await response.json().catch(() => ({}));
      showMessage(result.message || `Saved "${safeName}.json" on the server.`, 'success', 3500);
    } catch (err) {
      console.error('saveProjectToServer error', err);
      showMessage('Unable to save project on the server.', 'error', 4000);
    }
  }

  async function loadProjectFromServer() {
    try {
      const listResp = await fetch('/list_projects');
      if (!listResp.ok) {
        const text = await listResp.text();
        throw new Error(text || 'list_projects failed');
      }
      const files = await listResp.json();
      if (!Array.isArray(files) || files.length === 0) {
        showMessage('No saved projects found on the server.', 'info', 3500);
        return;
      }
      const sortedFiles = files.slice().sort((a, b) => a.localeCompare(b));
      const choice = await showServerProjectPicker(sortedFiles);
      if (!choice) {
        showMessage('Server project selection cancelled.', 'warning', 3000);
        return;
      }
      const target = choice.toLowerCase().endsWith('.json') ? choice : `${choice}.json`;
      const loadResp = await fetch(`/load_project/${encodeURIComponent(target)}`);
      if (!loadResp.ok) {
        const text = await loadResp.text();
        throw new Error(text || 'load_project failed');
      }
      const data = await loadResp.json();
      applyProjectSnapshot(data);
      showMessage(`Loaded "${target}" from the server.`, 'success', 3500);
    } catch (err) {
      console.error('loadProjectFromServer error', err);
      showMessage('Unable to load project from the server.', 'error', 4000);
    }
  }

  async function handleProjectLoad(e) {
    const file = e.target.files?.[0];
    if (!file) return;
    try {
      const text = await file.text();
      const snapshot = JSON.parse(text);
      applyProjectSnapshot(snapshot);
      showMessage(`Loaded project from "${file.name}".`, 'success', 3500);
    } catch (err) {
      console.error('handleProjectLoad error', err);
      showMessage('Unable to load project. Ensure the file is valid.', 'error', 4000);
    } finally {
      e.target.value = '';
    }
  }

  function applyProjectSnapshot(snapshot) {
    const payload = snapshot && typeof snapshot === 'object'
      ? (snapshot.data && typeof snapshot.data === 'object' ? snapshot.data : snapshot)
      : null;
    if (!payload || !Array.isArray(payload.transactions)) {
      throw new Error('Project file missing transactions.');
    }

    state.transactions = payload.transactions.map(row =>
      ensureScheduleCCategoryField(Object.assign({}, row))
    );
    state.coaTable = Array.isArray(payload.coaTable)
      ? payload.coaTable.map(acc => Object.assign({}, acc))
      : [];
    state.rules = Array.isArray(payload.rules)
      ? payload.rules.map(rule => Object.assign({}, rule))
      : [];
    state.sort = payload.sort && typeof payload.sort === 'object'
      ? {
          tab: payload.sort.tab || '',
          column: Object.prototype.hasOwnProperty.call(payload.sort, 'column') ? payload.sort.column : null,
          direction: payload.sort.direction === 'desc' ? 'desc' : 'asc'
        }
      : { tab: '', column: null, direction: 'asc' };
    state.reportView = payload.reportView || 'pl';
    state.beginningBalance = Number(payload.beginningBalance) || 0;
    state.statementBalance = Number(payload.statementBalance) || 0;
    state.reconcileView = payload.reconcileView === 'detail' ? 'detail' : 'summary';
    state.selectedReconcileMonthKey = payload.selectedReconcileMonthKey || null;
    state.assignedFilter = payload.assignedFilter || null;
    const fingerprintArr = Array.isArray(payload.loadedTransactionFingerprints)
      ? payload.loadedTransactionFingerprints.filter(Boolean)
      : [];
    state.loadedTransactionFingerprints = new Set(fingerprintArr);

    if (!(state.selectedTxIndexes instanceof Set)) state.selectedTxIndexes = new Set();
    state.selectedTxIndexes.clear();
    state.anchorIndex = null;
    state.anchorContext = null;
    state.selectionContext = null;
    state.unassignedDisplayOrder = [];
    state.assignedDisplayOrder = [];
    if (!(state.selectedMonthlyTxIndexes instanceof Set)) state.selectedMonthlyTxIndexes = new Set();
    state.selectedMonthlyTxIndexes.clear();

    renderCoa();
    refreshAllDropdowns();
    renderUnassigned();
    renderAssigned();
    updateReports();
    updateReconcileView();
  }

  async function importTransactionsFromFile(file) {
    const data = await file.arrayBuffer();
    const wb = XLSX.read(data, { type: 'array' });
    const sheetName = wb.SheetNames[0];
    const ws = wb.Sheets[sheetName];
    const json = XLSX.utils.sheet_to_json(ws, { defval: '' });
    const normalized = json.map(row => ensureScheduleCCategoryField(row));
    if (normalized.length === 0) {
      showMessage(`"${file.name}" did not contain any transactions.`, 'warning', 3000);
      return { appended: 0, skippedDuplicate: false };
    }
    const fingerprint = fingerprintTransactions(normalized);
    if (!state.loadedTransactionFingerprints) state.loadedTransactionFingerprints = new Set();
    if (state.loadedTransactionFingerprints.has(fingerprint)) {
      showMessage(`"${file.name}" matches a file you've already loaded and was skipped.`, 'warning', 3500);
      return { appended: 0, skippedDuplicate: true };
    }
    state.loadedTransactionFingerprints.add(fingerprint);
    if (!Array.isArray(state.transactions) || state.transactions.length === 0) {
      state.transactions = normalized;
    } else {
      state.transactions = state.transactions.concat(normalized);
    }
    return { appended: normalized.length, skippedDuplicate: false };
  }

  document.getElementById('rules-input').addEventListener('change', async (e) => {
    const f = e.target.files[0];
    if (!f) return;
    const text = await f.text();
    // try JSON first
    try {
      const obj = JSON.parse(text);
      state.rules = Array.isArray(obj) ? obj : [obj];
      showMessage('Loaded rules (JSON)', 'info', 2000);
    } catch (err) {
      // fallback CSV simple parser
      const lines = text.split(/\r?\n/).map(l => l.trim()).filter(Boolean);
      state.rules = lines.map(l => {
        const parts = l.split(',').map(p=>p.trim());
        return { payee: parts[0], category: parts[1] || '', direction: parts[2] || '' };
      });
      showMessage('Loaded rules (CSV)', 'info', 2000);
    }
    // Ensure COA contains accounts referenced by rules, then apply rules
    addAccountsFromRules();
    const applied = applyRules();
    // remove metadata fields added by earlier runs
    clearAppliedRuleMetadata();
    if (applied > 0) {
      showMessage(`Applied ${applied} rule-based classifications`, 'info', 3000);
      renderUnassigned(); renderAssigned(); updateReports(); refreshAllDropdowns();
    }
  });

  // === Tabs ===
  document.querySelectorAll('.tab-btn').forEach(btn => btn.addEventListener('click', () => {
    const tab = btn.dataset.tab;
    document.querySelectorAll('.tab-btn').forEach(b => b.classList.remove('bg-indigo-50','text-indigo-700'));
    btn.classList.add('bg-indigo-50','text-indigo-700');
    document.querySelectorAll('.tab-content').forEach(c => c.classList.add('hidden'));
    document.querySelector(`[data-content="${tab}"]`).classList.remove('hidden');
    state.sort.tab = tab;
    if (tab === 'reports') {
      updateReports();
    } else if (tab === 'reconcile') {
      updateReconcileView();
      setReconcileView(state.reconcileView || 'summary');
    }
  }));

  document.querySelectorAll('.report-tab-btn').forEach(btn => {
    btn.addEventListener('click', () => setReportView(btn.dataset.reportTab));
  });
  document.querySelectorAll('.reconcile-sub-tab').forEach(btn => {
    btn.addEventListener('click', () => setReconcileView(btn.dataset.reconcileView || 'summary'));
  });
  setReportView(state.reportView);
  // default
  document.querySelector('[data-tab="unassigned"]').click();

  // === Transactions Tabs ===
  function buildHeaders(headers) {
    return headers.map(h => {
      const display = (h || '').toString().replace(/\b\w/g, ch => ch.toUpperCase());
      const active = state.sort.column === h;
      const dir = active ? (state.sort.direction === 'asc' ? ' ' : ' ') : '';
      // escape single quotes for safe inline single-quoted onclick
      const safe = ('' + h).replace(/'/g, "\\'");
      return `<th class="px-3 py-2 text-left cursor-pointer" onclick="sortByColumn('${safe}')">${display}${dir}</th>`;
    }).join('');
  }

  function smartCompare(a, b, dir) {
    const sa = (a === undefined || a === null) ? '' : String(a);
    const sb = (b === undefined || b === null) ? '' : String(b);
    const hasNumA = /\d/.test(sa);
    const hasNumB = /\d/.test(sb);
    if (hasNumA || hasNumB) {
      const na = parseAmount(sa);
      const nb = parseAmount(sb);
      if (na < nb) return dir === 'asc' ? -1 : 1;
      if (na > nb) return dir === 'asc' ? 1 : -1;
      return 0;
    }
    const la = sa.toLowerCase(); const lb = sb.toLowerCase();
    if (la < lb) return dir === 'asc' ? -1 : 1;
    if (la > lb) return dir === 'asc' ? 1 : -1;
    return 0;
  }

  function sortByColumn(col) {
    if (state.sort.column === col) state.sort.direction = state.sort.direction === 'asc' ? 'desc' : 'asc';
    else { state.sort.column = col; state.sort.direction = 'asc'; }
    // re-render current tab (default to unassigned)
    if (state.sort.tab === 'assigned') renderAssigned(); else renderUnassigned();
  }

  function renderUnassigned() {
    state.dragSelecting = false;
    state.dragStartOrder = null;
    const tbody = document.getElementById('unassigned-body');
    const head = document.getElementById('unassigned-head');
    tbody.innerHTML = '';
    // build headers dynamically
    if (state.transactions.length === 0) {
      head.innerHTML = '<tr><th class="px-3 py-2 text-left">No data loaded</th></tr>';
      state.unassignedDisplayOrder = [];
      updateSelectionUI();
      return;
    }
    // Exclude 'Schedule C Category' from the main table columns so copying transactions won't include it
    const headers = Object.keys(state.transactions[0]).filter(h => h !== 'Schedule C Category');
  // include a visible Category header but mark it no-copy so clipboard strips it
  head.innerHTML = '<tr>' + buildHeaders(headers) + '<th class="px-3 py-2 no-copy">Category</th><th class="px-3 py-2 text-center no-copy"><input id="unassigned-select-all" type="checkbox" title="Select visible"/></th></tr>';

    // Build list of unassigned items and apply sorting if requested
    let items = state.transactions.map((tx, idx) => ({ tx, idx })).filter(item => !item.tx['Schedule C Category']);
    if (state.sort.column) {
      items.sort((a,b) => smartCompare(a.tx[state.sort.column], b.tx[state.sort.column], state.sort.direction));
    }
    state.unassignedDisplayOrder = items.map(item => item.idx);

    // attach handler to header select-all checkbox after rows render
    setTimeout(() => {
      const chk = document.getElementById('unassigned-select-all');
      if (chk) {
        const visibleIdx = Array.isArray(state.unassignedDisplayOrder) ? state.unassignedDisplayOrder.slice() : [];
        const selectedCount = visibleIdx.filter(i => state.selectedTxIndexes.has(i)).length;
        chk.checked = visibleIdx.length > 0 && selectedCount === visibleIdx.length;
        chk.indeterminate = visibleIdx.length > 0 && selectedCount > 0 && selectedCount < visibleIdx.length;
        chk.onchange = (ev) => {
          const currentVisible = Array.isArray(state.unassignedDisplayOrder) ? state.unassignedDisplayOrder.slice() : [];
          if (ev.target.checked) {
            currentVisible.forEach(i => state.selectedTxIndexes.add(i));
            if (currentVisible.length > 0) {
              state.anchorIndex = currentVisible[0];
              state.anchorContext = 'unassigned';
              state.selectionContext = 'unassigned';
            }
          } else {
            currentVisible.forEach(i => state.selectedTxIndexes.delete(i));
            state.anchorIndex = null;
            state.anchorContext = null;
            state.selectionContext = null;
          }
          updateSelectionUI();
        };
      }
    }, 0);

    items.forEach(({tx, idx}, order) => {
      const tr = document.createElement('tr');
      tr.className = 'hover:bg-gray-50 border-b';
      tr.dataset.idx = idx;
      tr.dataset.order = order;

      headers.forEach(h => {
        const td = document.createElement('td');
        td.className = 'px-3 py-2';
        const value = getDisplayValueForColumn(h, tx[h]);
        td.textContent = value;
        if ((h || '').toString().toLowerCase().includes('amount')) {
          const tone = getAmountCssClass(tx[h]);
          if (tone) td.className += ' ' + tone;
        }
        tr.appendChild(td);
      });

      // Schedule C Category select as a separate cell at the end (marked no-copy so clipboard won't include it)
      const catTd = document.createElement('td');
      catTd.className = 'px-3 py-2 no-copy';
      const sel = document.createElement('select');
      sel.className = 'rounded border px-2 py-1';
      sel.addEventListener('change', (e) => {
        tx['Schedule C Category'] = e.target.value;
        // move to assigned (stay in state, just renders differently)
        renderUnassigned(); renderAssigned(); updateReports();
        refreshAllDropdowns();
      });
      const placeholder = document.createElement('option');
      placeholder.textContent = '-- Select Category --';
      placeholder.value = '';
      sel.appendChild(placeholder);
      state.coaTable.forEach(a => {
        const o = document.createElement('option'); o.value = a['Account Name']; o.textContent = a['Account Name'];
        if (tx['Schedule C Category'] === a['Account Name']) o.selected = true;
        sel.appendChild(o);
      });
      catTd.appendChild(sel);
      tr.appendChild(catTd);

      // row click for selection (support shift/ctrl handled in handler)
      tr.addEventListener('click', (ev) => {
        // ignore clicks that are on interactive elements handled separately
        if (ev.target.tagName === 'INPUT' || ev.target.tagName === 'SELECT' || ev.target.tagName === 'BUTTON') return;
        if (state.dragSelecting || state.dragJustFinished) {
          ev.preventDefault();
          return;
        }
        handleTxSelection(ev, idx, 'unassigned');
      });
      tr.addEventListener('mousedown', (ev) => onUnassignedRowMouseDown(ev, order));
      tr.addEventListener('mouseenter', (ev) => onUnassignedRowMouseEnter(ev, order));

      // visual selected
      if (state.selectedTxIndexes.has(idx)) tr.classList.add('bg-indigo-50');

      const selectTd = document.createElement('td');
      selectTd.className = 'px-3 py-2 text-center no-copy';
      const cb = document.createElement('input');
      cb.type = 'checkbox';
      cb.checked = state.selectedTxIndexes.has(idx);
      cb.addEventListener('click', (ev) => handleTxSelection(ev, idx, 'unassigned'));
      selectTd.appendChild(cb);
      tr.appendChild(selectTd);

      tbody.appendChild(tr);
    });

    // enable/disable reclassify button
    const tabCounter = document.getElementById('tab-unassigned-count');
    if (tabCounter) tabCounter.textContent = `(${items.length})`;
    updateSelectionUI();
  }

  // Intercept copy gestures when selection is within the unassigned table and strip cells marked 'no-copy'
  document.addEventListener('copy', (e) => {
    try {
      const table = document.getElementById('unassigned-table');
      if (!table) return;
      const selection = window.getSelection();
      if (!selection || selection.isCollapsed) return;
      const textNodeType = (typeof Node !== 'undefined' && Node.TEXT_NODE) || 3;
      const resolveNode = (node) => {
        if (!node) return null;
        return node.nodeType === textNodeType ? node.parentNode : node;
      };
      const anchor = resolveNode(selection.anchorNode);
      const focus = resolveNode(selection.focusNode);
      if (!table.contains(anchor) && !table.contains(focus)) return;
      const range = selection.getRangeAt(0);
      if (!table.contains(resolveNode(range.commonAncestorContainer))) return;
      const frag = range.cloneContents();
      Array.from(frag.querySelectorAll('.no-copy')).forEach(n => n.remove());

      const rows = Array.from(frag.querySelectorAll('tr')).map(tr => {
        const cells = Array.from(tr.children).filter(cell => cell.tagName === 'TD' || cell.tagName === 'TH');
        if (!cells.length) return null;
        return cells.map(cell => ({
          html: cell.innerHTML,
          text: cell.textContent.replace(/\s+/g, ' ').trim()
        }));
      }).filter(Boolean);

      if (rows.length === 0) return;

      const htmlParts = ['<table><tbody>'];
      rows.forEach(row => {
        htmlParts.push('<tr>');
        row.forEach(cell => htmlParts.push(`<td>${cell.html}</td>`));
        htmlParts.push('</tr>');
      });
      htmlParts.push('</tbody></table>');
      const html = htmlParts.join('');

      const text = rows.map(row => row.map(cell => cell.text).join('\t')).join('\r\n');

      e.clipboardData.setData('text/html', html);
      e.clipboardData.setData('text/plain', text);
      e.preventDefault();
    } catch (err) { /* ignore */ }
  });

  function renderAssigned(filterAccount) {
    // If caller omitted filterAccount, use the stored filter in state (so selection won't clear it)
    if (typeof filterAccount === 'undefined') filterAccount = state.assignedFilter || null;
    else state.assignedFilter = filterAccount;

  const tbody = document.getElementById('assigned-body');
  const head = document.getElementById('assigned-head');
  tbody.innerHTML = '';
  if (state.transactions.length === 0) {
    head.innerHTML = '<tr><th class="px-3 py-2">No data loaded</th></tr>';
    state.assignedDisplayOrder = [];
    updateSelectionUI();
    return;
  }
    const headers = Object.keys(state.transactions[0]);
    // include a select checkbox in the header for selecting all visible assigned items
    head.innerHTML = '<tr>' + buildHeaders(headers) + '<th class="px-3 py-2 text-center no-copy"><input id="assigned-select-all" type="checkbox" title="Select visible"/></th></tr>';

    // Build list of assigned items and apply sorting if requested
    let items = state.transactions.map((tx, idx) => ({ tx, idx })).filter(item => item.tx['Schedule C Category']);
    if (filterAccount) items = items.filter(item => item.tx['Schedule C Category'] === filterAccount);
    if (state.sort.column) {
      items.sort((a,b) => smartCompare(a.tx[state.sort.column], b.tx[state.sort.column], state.sort.direction));
    }

    if (items.length === 0) {
      state.assignedDisplayOrder = [];
    } else {
      state.assignedDisplayOrder = items.map(it => it.idx);
    }

  // visible indexes for the select-all header checkbox
    const visibleIdx = state.assignedDisplayOrder.slice();

    // attach handler to header select-all checkbox (deferred so element exists)
    setTimeout(() => {
      const chk = document.getElementById('assigned-select-all');
      if (chk) {
        chk.checked = visibleIdx.length > 0 && visibleIdx.every(i => state.selectedTxIndexes.has(i));
        chk.addEventListener('change', (ev) => {
          if (ev.target.checked) {
            visibleIdx.forEach(i => state.selectedTxIndexes.add(i));
            if (visibleIdx.length > 0) {
              state.anchorIndex = visibleIdx[0];
              state.anchorContext = 'assigned';
              state.selectionContext = 'assigned';
            }
          } else {
            visibleIdx.forEach(i => state.selectedTxIndexes.delete(i));
            state.anchorIndex = null;
            state.anchorContext = null;
            state.selectionContext = null;
          }
          updateSelectionUI();
        });
      }
    }, 0);

    items.forEach(({tx, idx}, order) => {
      const tr = document.createElement('tr');
      tr.className = 'hover:bg-gray-50 border-b';
      tr.dataset.idx = idx;
      // render each field
      Object.keys(tx).forEach(h => {
        const td = document.createElement('td');
        td.className = 'px-3 py-2';
        const value = getDisplayValueForColumn(h, tx[h]);
        td.textContent = value;
        if ((h || '').toString().toLowerCase().includes('amount')) {
          const tone = getAmountCssClass(tx[h]);
          if (tone) td.className += ' ' + tone;
        }
        tr.appendChild(td);
      });

      // selection checkbox
      const selTd = document.createElement('td');
      selTd.className = 'px-3 py-2 text-center no-copy';
      const cb = document.createElement('input');
      cb.type = 'checkbox';
      cb.checked = state.selectedTxIndexes.has(idx);
      cb.addEventListener('click', (ev) => handleTxSelection(ev, idx, 'assigned'));
      selTd.appendChild(cb);
      tr.appendChild(selTd);

      // row click for selection (ignore interactive elements)
      tr.addEventListener('click', (ev) => {
        if (ev.target.tagName === 'INPUT' || ev.target.tagName === 'SELECT' || ev.target.tagName === 'BUTTON') return;
        handleTxSelection(ev, idx, 'assigned');
      });

      if (state.selectedTxIndexes.has(idx)) tr.classList.add('bg-indigo-50');

      tbody.appendChild(tr);
    });

    // enable/disable assigned reclassify header button
    const assignedReclass = document.getElementById('assigned-reclassify-button');
    if (assignedReclass) assignedReclass.disabled = state.selectedTxIndexes.size === 0;
    const tabCounter = document.getElementById('tab-assigned-count');
    if (tabCounter) tabCounter.textContent = `(${items.length})`;
    updateSelectionUI();
  }

  // === Selection handler (supports shift & ctrl/cmd) ===
  function handleTxSelection(ev, idx, context=null) {
    state.dragJustFinished = false;
    const ctx = context || state.selectionContext || 'unassigned';
    state.selectionContext = ctx;
    const orderList = ctx === 'assigned' ? state.assignedDisplayOrder : state.unassignedDisplayOrder;
    const set = state.selectedTxIndexes;
    const isShift = !!ev.shiftKey;
    const meta = ev.ctrlKey || ev.metaKey;
    const targetIsInput = (ev.target.tagName || '').toUpperCase() === 'INPUT';
    const ensureAnchor = (value) => {
      state.anchorIndex = value;
      state.anchorContext = ctx;
    };

    if (isShift && Array.isArray(orderList) && orderList.length > 0) {
      const anchorValid = state.anchorContext === ctx && state.anchorIndex !== null && orderList.indexOf(state.anchorIndex) !== -1;
      const anchorIdx = anchorValid ? state.anchorIndex : (orderList.indexOf(idx) !== -1 ? idx : orderList[0]);
      const anchorPos = orderList.indexOf(anchorIdx);
      const targetPos = orderList.indexOf(idx);
      if (anchorPos !== -1 && targetPos !== -1) {
        const minOrder = Math.min(anchorPos, targetPos);
        const maxOrder = Math.max(anchorPos, targetPos);
        set.clear();
        for (let pos = minOrder; pos <= maxOrder; pos++) {
          const txIdx = orderList[pos];
          if (txIdx !== undefined) set.add(txIdx);
        }
        ensureAnchor(anchorIdx);
      } else {
        set.clear();
        set.add(idx);
        ensureAnchor(idx);
      }
    } else if (meta) {
      if (set.has(idx)) set.delete(idx); else set.add(idx);
      ensureAnchor(idx);
    } else {
      if (targetIsInput) {
        if (ev.target.checked) {
          set.clear();
          set.add(idx);
          ensureAnchor(idx);
        } else {
          set.delete(idx);
          ensureAnchor(idx);
        }
      } else {
        set.clear();
        set.add(idx);
        ensureAnchor(idx);
      }
    }
    updateSelectionUI();
  }

  function updateMonthlyControls() {
    const isDetail = state.reconcileView === 'detail';
    const hasMonth = !!state.selectedReconcileMonthKey;
    const hasSelection = state.selectedMonthlyTxIndexes && state.selectedMonthlyTxIndexes.size > 0;
    const toggleBtn = document.getElementById('reconcile-detail-toggle');
    if (toggleBtn) {
      toggleBtn.classList.toggle('hidden', !isDetail);
      toggleBtn.disabled = !isDetail || !hasSelection;
    }
    const addBtn = document.getElementById('reconcile-detail-add');
    if (addBtn) {
      addBtn.classList.toggle('hidden', !isDetail);
      addBtn.disabled = !isDetail || !hasMonth;
      addBtn.classList.toggle('opacity-50', !hasMonth);
      addBtn.classList.toggle('cursor-not-allowed', !hasMonth);
    }
    const deleteBtn = document.getElementById('reconcile-detail-delete');
    if (deleteBtn) {
      deleteBtn.classList.toggle('hidden', !isDetail);
      deleteBtn.disabled = !isDetail || !hasSelection;
    }
    const selectAll = document.getElementById('reconcile-detail-select-all');
    if (selectAll) {
      const disabled = !isDetail || !hasMonth;
      selectAll.disabled = disabled;
      if (disabled) {
        selectAll.checked = false;
        selectAll.indeterminate = false;
      }
    }
  }

  function handleMonthlySelection(index, selected) {
    if (!Number.isInteger(index)) return;
    if (!state.selectedMonthlyTxIndexes) state.selectedMonthlyTxIndexes = new Set();
    if (selected) state.selectedMonthlyTxIndexes.add(index);
    else state.selectedMonthlyTxIndexes.delete(index);
    renderReconcileDetail();
  }

  function setReconcileView(view) {
    const desired = view === 'detail' ? 'detail' : 'summary';
    state.reconcileView = desired;

    const summarySection = document.getElementById('reconcile-summary-view');
    const detailSection = document.getElementById('reconcile-detail-view');
    if (summarySection) summarySection.classList.toggle('hidden', desired !== 'summary');
    if (detailSection) detailSection.classList.toggle('hidden', desired !== 'detail');

    if (desired === 'detail') {
      renderReconcileDetail();
    }

    const rangeEl = document.getElementById('reconcile-detail-current-range');
    if (rangeEl) {
      const hasRange = Boolean((rangeEl.dataset.rangeAvailable || '').trim());
      const shouldShow = desired === 'detail' && hasRange;
      rangeEl.classList.toggle('hidden', !shouldShow);
    }

    document.querySelectorAll('.reconcile-sub-tab').forEach(btn => {
      const btnView = (btn.dataset.reconcileView === 'detail') ? 'detail' : 'summary';
      const isActive = btnView === desired;
      btn.classList.toggle('bg-white', isActive);
      btn.classList.toggle('shadow', isActive);
      btn.classList.toggle('text-indigo-600', isActive);
      btn.classList.toggle('text-gray-600', !isActive);
    });

    updateMonthlyControls();
  }

  function resolveTransactionDateValue(tx) {
    if (!tx) return '';
    const fields = [
      'Cleared Date',
      'Date',
      'Transaction Date',
      'Transactions Date',
      'Txn Date',
      'Posted Date'
    ];
    for (const field of fields) {
      const value = resolveFieldValue(tx, field);
      if (value !== undefined && value !== null && String(value).trim() !== '') {
        return value;
      }
    }
    return '';
  }

  function getTransactionCopyDate(tx) {
    const raw = resolveTransactionDateValue(tx);
    if (raw === undefined || raw === null || raw === '') return '';
    const formatted = formatDateDisplay(raw);
    return formatted || String(raw);
  }

  function getTransactionCopyDescription(tx) {
    const fields = [
      'Description',
      'Transaction Description',
      'Transactions Description',
      'Memo',
      'Payee',
      'Details'
    ];
    for (const field of fields) {
      const value = resolveFieldValue(tx, field);
      if (value !== undefined && value !== null && String(value).trim() !== '') {
        return String(value).trim();
      }
    }
    return '';
  }

  function sanitizeClipboardValue(value) {
    if (value === null || value === undefined) return '';
    return value.toString().replace(/\r?\n|\r/g, ' ').trim();
  }

  function getAmountCssClass(value) {
    const amount = parseAmount(value);
    if (!Number.isFinite(amount) || Math.abs(amount) < 1e-9) return '';
    return amount > 0 ? 'text-green-600 font-semibold' : 'text-red-600 font-semibold';
  }

  function getTransactionAmount(tx) {
    if (!tx || typeof tx !== 'object') return 0;
    const raw = resolveFieldValue(tx, 'Amount');
    if (raw !== undefined && raw !== null && String(raw).trim() !== '') {
      return parseAmount(raw);
    }
    return parseAmount(tx['Amount'] ?? tx['amount'] ?? tx.Amount ?? 0);
  }

  function coerceDateValue(raw) {
    if (raw === null || raw === undefined || raw === '') return null;
    if (raw instanceof Date) {
      const copy = new Date(raw.getTime());
      return Number.isNaN(copy.getTime()) ? null : copy;
    }
    if (typeof raw === 'number' && Number.isFinite(raw)) {
      if (typeof XLSX !== 'undefined' && XLSX.SSF && typeof XLSX.SSF.parse_date_code === 'function') {
        const parsed = XLSX.SSF.parse_date_code(raw);
        if (parsed && parsed.y) return new Date(parsed.y, parsed.m - 1, parsed.d);
      }
      const excelEpoch = new Date(Date.UTC(1899, 11, 30));
      const dateFromSerial = new Date(excelEpoch.getTime() + raw * 86400000);
      return Number.isNaN(dateFromSerial.getTime()) ? null : dateFromSerial;
    }
    const str = String(raw).trim();
    if (!str) return null;
    // ISO format
    const isoMatch = str.match(/^(\d{4})-(\d{2})-(\d{2})/);
    if (isoMatch) {
      const year = Number(isoMatch[1]);
      const month = Number(isoMatch[2]);
      const day = Number(isoMatch[3]);
      const isoDate = new Date(year, month - 1, day);
      if (!Number.isNaN(isoDate.getTime())) return isoDate;
    }
    // MM/DD/YYYY or similar
    const slashMatch = str.match(/^(\d{1,2})[\/\-](\d{1,2})[\/\-](\d{2,4})$/);
    if (slashMatch) {
      let year = Number(slashMatch[3]);
      if (year < 100) year += 2000;
      const month = Number(slashMatch[1]);
      const day = Number(slashMatch[2]);
      const formatted = new Date(year, month - 1, day);
      if (!Number.isNaN(formatted.getTime())) return formatted;
    }
    const parsed = new Date(str);
    if (!Number.isNaN(parsed.getTime())) return parsed;
    return null;
  }

  function formatMonthLabel(year, monthIndex) {
    const date = new Date(year, monthIndex, 1);
    return date.toLocaleDateString(undefined, { year: 'numeric', month: 'long' });
  }

  function formatDateForInput(raw) {
    const date = coerceDateValue(raw);
    if (!date) return '';
    const month = String(date.getMonth() + 1).padStart(2, '0');
    const day = String(date.getDate()).padStart(2, '0');
    return `${date.getFullYear()}-${month}-${day}`;
  }

  function normalizeInputDate(value) {
    if (!value) return '';
    if (typeof value === 'string' && /^\d{4}-\d{2}-\d{2}$/.test(value)) {
      const [year, month, day] = value.split('-');
      return `${month}/${day}/${year}`;
    }
    const str = formatDateForIif(value);
    return str || '';
  }

  function updateReconcileView() {
    const beginning = Number(state.beginningBalance) || 0;
    const statement = Number(state.statementBalance) || 0;
    const txs = Array.isArray(state.transactions) ? state.transactions : [];
    let paymentsTotal = 0;
    let depositsTotal = 0;
    let paymentCount = 0;
    let depositCount = 0;

    const monthlyMap = new Map();

    txs.forEach((tx, idx) => {
      const amount = getTransactionAmount(tx);
      if (!Number.isFinite(amount) || amount === 0) return;

      if (amount > 0) {
        depositsTotal += amount;
        depositCount += 1;
      } else {
        paymentsTotal += amount;
        paymentCount += 1;
      }

      const rawDate = tx['Cleared Date'] ?? tx['Date'] ?? tx.date ?? null;
      const date = coerceDateValue(rawDate);
      if (!date) return;

      const year = date.getFullYear();
      const monthIndex = date.getMonth();
      const monthKey = `${year}-${String(monthIndex + 1).padStart(2, '0')}`;
      const monthLabel = formatMonthLabel(year, monthIndex);
      const monthEntry = monthlyMap.get(monthKey) || {
        key: monthKey,
        year,
        monthIndex,
        label: monthLabel,
        netActivity: 0,
        paymentsTotal: 0,
        paymentsCount: 0,
        depositsTotal: 0,
        depositsCount: 0,
        transactions: []
      };

      monthEntry.netActivity += amount;
      if (amount > 0) {
        monthEntry.depositsTotal += amount;
        monthEntry.depositsCount += 1;
      } else {
        monthEntry.paymentsTotal += amount;
        monthEntry.paymentsCount += 1;
      }

      const displayDate = formatDateForIif(date);
      const description = getTransactionCopyDescription(tx);
      monthEntry.transactions.push({
        amount,
        date,
        displayDate,
        description,
        originalIndex: idx
      });

      monthlyMap.set(monthKey, monthEntry);
    });

    const cleared = beginning + paymentsTotal + depositsTotal;
    const difference = statement - cleared;

    const beginningEl = document.getElementById('reconcile-beginning');
    const paymentsEl = document.getElementById('reconcile-payments');
    const depositsEl = document.getElementById('reconcile-deposits');
    const clearedEl = document.getElementById('reconcile-cleared');
    const statementEl = document.getElementById('reconcile-statement');
    const differenceEl = document.getElementById('reconcile-difference');
    const paymentsCountEl = document.getElementById('reconcile-payments-count');
    const depositsCountEl = document.getElementById('reconcile-deposits-count');

    if (beginningEl) beginningEl.textContent = formatCurrency(beginning);
    if (paymentsEl) paymentsEl.textContent = formatCurrency(paymentsTotal);
    if (depositsEl) depositsEl.textContent = formatCurrency(depositsTotal);
    if (clearedEl) clearedEl.textContent = formatCurrency(cleared);
    if (statementEl) statementEl.textContent = `Statement Ending Balance: ${formatCurrency(statement)}`;
    if (paymentsCountEl) paymentsCountEl.textContent = `${paymentCount} ${paymentCount === 1 ? 'payment' : 'payments'}`;
    if (depositsCountEl) depositsCountEl.textContent = `${depositCount} ${depositCount === 1 ? 'deposit' : 'deposits'}`;
    if (differenceEl) {
      differenceEl.textContent = formatCurrency(difference);
      const base = 'mt-1 text-xl font-bold';
      const tone = Math.abs(difference) < 0.01 ? ' text-emerald-600' : difference > 0 ? ' text-amber-600' : ' text-rose-600';
      differenceEl.className = base + tone;
    }

    const monthlyEntries = Array.from(monthlyMap.values()).sort((a, b) => {
      if (a.year === b.year) return a.monthIndex - b.monthIndex;
      return a.year - b.year;
    });

    let runningBalance = beginning;
    monthlyEntries.forEach(entry => {
      entry.beginningBalance = runningBalance;

      entry.transactions.sort((a, b) => {
        const diff = a.date.getTime() - b.date.getTime();
        if (diff !== 0) return diff;
        return a.originalIndex - b.originalIndex;
      });

      const detailRows = [];
      let dayBuffer = [];
      let currentDay = '';
      let monthRunning = runningBalance;
      let firstDate = null;
      let lastDate = null;

      const flushDay = () => {
        if (dayBuffer.length === 0) return;
        dayBuffer.forEach((tx, index) => {
          monthRunning += tx.amount;
          const isLastOfDay = index === dayBuffer.length - 1;
          detailRows.push({
            date: tx.date,
            displayDate: tx.displayDate,
            description: tx.description,
            amount: tx.amount,
            showBalance: isLastOfDay,
            runningBalance: isLastOfDay ? monthRunning : null,
            originalIndex: tx.originalIndex
          });
        });
        dayBuffer = [];
      };

      entry.transactions.forEach(tx => {
        if (!firstDate || tx.date < firstDate) firstDate = tx.date;
        if (!lastDate || tx.date > lastDate) lastDate = tx.date;
        const dayKey = `${tx.date.getFullYear()}-${String(tx.date.getMonth() + 1).padStart(2, '0')}-${String(tx.date.getDate()).padStart(2, '0')}`;
        if (currentDay && dayKey !== currentDay) flushDay();
        currentDay = dayKey;
        dayBuffer.push(tx);
      });

      flushDay();

      entry.rows = detailRows;
      entry.endingBalance = monthRunning;
      entry.startDate = firstDate;
      entry.endDate = lastDate;

      runningBalance = entry.endingBalance;
    });

    const monthlyBody = document.getElementById('reconcile-monthly-body');
    if (monthlyBody) {
      if (monthlyEntries.length === 0) {
        monthlyBody.innerHTML = '<tr><td class="px-3 py-3 text-center text-gray-400" colspan="3">No transactions available.</td></tr>';
      } else {
        monthlyBody.innerHTML = '';
        monthlyEntries.forEach(entry => {
          const tr = document.createElement('tr');
          tr.className = 'border-b last:border-b-0 cursor-pointer transition hover:bg-indigo-50';
          if (state.selectedReconcileMonthKey === entry.key) {
            tr.classList.add('bg-indigo-50/70');
          }
          tr.dataset.monthKey = entry.key;

          const nameTd = document.createElement('td');
          nameTd.className = 'px-3 py-2 text-gray-700 font-medium';
          nameTd.textContent = entry.label;

          const netTd = document.createElement('td');
          netTd.className = `px-3 py-2 text-right ${entry.netActivity >= 0 ? 'text-emerald-600 font-semibold' : 'text-red-600 font-semibold'}`;
          netTd.textContent = formatCurrency(entry.netActivity);

          const endingTd = document.createElement('td');
          endingTd.className = 'px-3 py-2 text-right font-semibold text-gray-700';
          endingTd.textContent = formatCurrency(entry.endingBalance);

          tr.appendChild(nameTd);
          tr.appendChild(netTd);
          tr.appendChild(endingTd);

          tr.addEventListener('click', () => {
            state.selectedReconcileMonthKey = entry.key;
            setReconcileView('detail');
          });

          monthlyBody.appendChild(tr);
        });
      }
    }

    const validKeys = new Set(monthlyEntries.map(entry => entry.key));
    if (state.selectedReconcileMonthKey && !validKeys.has(state.selectedReconcileMonthKey)) {
      state.selectedReconcileMonthKey = monthlyEntries.length > 0 ? monthlyEntries[monthlyEntries.length - 1].key : null;
    }

    state.reconcileMonthlyData = monthlyEntries;

    setReconcileView(state.reconcileView || 'summary');
  }

  function renderReconcileDetail() {
    const subtitleEl = document.getElementById('reconcile-detail-subtitle');
    const rangeEl = document.getElementById('reconcile-detail-current-range');
    const bodyEl = document.getElementById('reconcile-detail-body');
    const beginningEl = document.getElementById('reconcile-detail-beginning');
    const paymentsEl = document.getElementById('reconcile-detail-payments');
    const paymentsCountEl = document.getElementById('reconcile-detail-payments-count');
    const depositsEl = document.getElementById('reconcile-detail-deposits');
    const depositsCountEl = document.getElementById('reconcile-detail-deposits-count');
    const endingEl = document.getElementById('reconcile-detail-ending');

    const data = Array.isArray(state.reconcileMonthlyData) ? state.reconcileMonthlyData : [];
    const selectedKey = state.selectedReconcileMonthKey;
    const entry = selectedKey ? data.find(item => item.key === selectedKey) : null;
    const defaultSubtitle = 'Select a month from the summary to view its transactions.';
    const selectionSet = state.selectedMonthlyTxIndexes || (state.selectedMonthlyTxIndexes = new Set());

    const summaryRows = document.querySelectorAll('#reconcile-monthly-body tr');
    summaryRows.forEach(row => {
      if (row.dataset && row.dataset.monthKey === selectedKey) row.classList.add('bg-indigo-50/70');
      else row.classList.remove('bg-indigo-50/70');
    });

    const headerRow = document.querySelector('#reconcile-detail-body')?.closest('table')?.querySelector('thead tr');
    const buildHeader = (extraCols) => {
      if (!headerRow) return;
      const extraHeaderCells = extraCols.map(field => `<th class="px-3 py-2 text-left">${field}</th>`).join('');
      headerRow.innerHTML = `
        <th class="px-3 py-2 text-left"><input id="reconcile-detail-select-all" type="checkbox" class="rounded border-slate-300" /></th>
        <th class="px-3 py-2 text-left">Date</th>
        <th class="px-3 py-2 text-left">Description</th>
        ${extraHeaderCells}
        <th class="px-3 py-2 text-right">Withdraw</th>
        <th class="px-3 py-2 text-right">Deposit</th>
        <th class="px-3 py-2 text-right">Daily Balance</th>
        <th class="px-3 py-2 text-right">Actions</th>`;
    };

    const hasRows = entry && Array.isArray(entry.rows) && entry.rows.length > 0;
    const extraFields = [];
    if (hasRows) {
      const excludedNormalized = new Set([
        'date','cleared date','transaction date','transactions date','txn date','posted date',
        'description','memo','payee','details',
        'amount','deposit','deposits','money in','credit','charge','withdrawal','withdrawals','money out','debit','schedule c category'
      ].map(normalizeColumnKey));
      const fieldOrder = [];
      const fieldMap = new Map();
      entry.rows.forEach(row => {
        const tx = Number.isInteger(row.originalIndex) ? state.transactions[row.originalIndex] : null;
        if (!tx || typeof tx !== 'object') return;
        Object.keys(tx).forEach(key => {
          const normalized = normalizeColumnKey(key);
          if (!normalized || excludedNormalized.has(normalized)) return;
          if (!fieldMap.has(normalized)) {
            fieldMap.set(normalized, key);
            fieldOrder.push(normalized);
          }
        });
      });
      fieldOrder.forEach(normalized => {
        const originalKey = fieldMap.get(normalized);
        if (originalKey) extraFields.push(originalKey);
      });
    }

    buildHeader(extraFields);
    const selectAllCheckbox = document.getElementById('reconcile-detail-select-all');

    if (!hasRows) {
      selectionSet.clear();
      const hasEntry = !!entry;
      if (subtitleEl) {
        if (hasEntry) {
          const monthLabel = entry?.label || 'this month';
          subtitleEl.textContent = `No transactions found for ${monthLabel}.`;
        } else {
          subtitleEl.textContent = defaultSubtitle;
        }
      }
      if (rangeEl) {
        rangeEl.textContent = '';
        rangeEl.dataset.rangeAvailable = '';
        rangeEl.classList.add('hidden');
      }
      if (bodyEl) {
        const colSpan = 7 + extraFields.length;
        const message = hasEntry ? 'No transactions available for this month.' : 'No month selected.';
        bodyEl.innerHTML = `<tr><td class="px-3 py-3 text-center text-gray-400" colspan="${colSpan}">${message}</td></tr>`;
      }
      if (beginningEl) beginningEl.textContent = formatCurrency(0);
      if (paymentsEl) paymentsEl.textContent = formatCurrency(0);
      if (depositsEl) depositsEl.textContent = formatCurrency(0);
      if (endingEl) endingEl.textContent = formatCurrency(0);
      if (paymentsCountEl) paymentsCountEl.textContent = '';
      if (depositsCountEl) depositsCountEl.textContent = '';
      if (selectAllCheckbox) {
        selectAllCheckbox.checked = false;
        selectAllCheckbox.indeterminate = false;
        selectAllCheckbox.disabled = true;
        selectAllCheckbox.onchange = null;
      }
      updateMonthlyControls();
      return;
    }

    if (subtitleEl) subtitleEl.textContent = `Transactions for ${entry.label}`;

    if (rangeEl) {
      let rangeText = '';
      if (entry.startDate && entry.endDate) {
        const start = formatDateForIif(entry.startDate);
        const end = formatDateForIif(entry.endDate);
        rangeText = start === end ? `Date: ${start}` : `Date range: ${start} - ${end}`;
      }
      rangeEl.textContent = rangeText;
      rangeEl.dataset.rangeAvailable = rangeText ? '1' : '';
      const shouldShow = !!rangeText && state.reconcileView === 'detail';
      rangeEl.classList.toggle('hidden', !shouldShow);
    }

    const validIndexes = new Set(entry.rows.map(row => row.originalIndex).filter(Number.isInteger));
    selectionSet.forEach(idx => {
      if (!validIndexes.has(idx)) selectionSet.delete(idx);
    });

    if (selectAllCheckbox) {
      const selectedCount = Array.from(selectionSet).filter(idx => validIndexes.has(idx)).length;
      selectAllCheckbox.disabled = entry.rows.length === 0;
      selectAllCheckbox.checked = entry.rows.length > 0 && selectedCount === entry.rows.length;
      selectAllCheckbox.indeterminate = selectedCount > 0 && selectedCount < entry.rows.length;
      selectAllCheckbox.onchange = (ev) => {
        if (ev.target.checked) {
          entry.rows.forEach(row => {
            if (Number.isInteger(row.originalIndex)) selectionSet.add(row.originalIndex);
          });
        } else {
          entry.rows.forEach(row => {
            if (Number.isInteger(row.originalIndex)) selectionSet.delete(row.originalIndex);
          });
        }
        renderReconcileDetail();
      };
    }

    if (bodyEl) {
      bodyEl.innerHTML = '';
      entry.rows.forEach(row => {
        const tr = document.createElement('tr');
        tr.className = 'border-b last:border-b-0 hover:bg-gray-50';
        const originalIndex = row.originalIndex;
        const canSelect = Number.isInteger(originalIndex);
        const isSelected = canSelect && selectionSet.has(originalIndex);
        if (isSelected) tr.classList.add('bg-indigo-50');

        const tx = canSelect ? state.transactions[originalIndex] : null;

        const selectTd = document.createElement('td');
        selectTd.className = 'px-3 py-2 text-center';
        const cb = document.createElement('input');
        cb.type = 'checkbox';
        cb.className = 'rounded border-slate-300';
        cb.checked = isSelected;
        cb.disabled = !canSelect;
        cb.addEventListener('change', (ev) => {
          if (!canSelect) return;
          handleMonthlySelection(originalIndex, ev.target.checked);
        });
        selectTd.appendChild(cb);

        const dateTd = document.createElement('td');
        dateTd.className = 'px-3 py-2 text-gray-700 whitespace-nowrap';
        dateTd.textContent = row.displayDate || '';

        const descTd = document.createElement('td');
        descTd.className = 'px-3 py-2 text-gray-700';
        descTd.textContent = row.description || '';

        const extraTds = extraFields.map(fieldName => {
          const td = document.createElement('td');
          td.className = 'px-3 py-2 text-gray-700';
          const value = tx ? getDisplayValueForColumn(fieldName, tx[fieldName]) : '';
          td.textContent = value === undefined || value === null ? '' : value;
          return td;
        });

        const withdrawTd = document.createElement('td');
        withdrawTd.className = 'px-3 py-2 text-right text-red-600 font-semibold';
        withdrawTd.textContent = row.amount < 0 ? formatCurrency(row.amount) : '';

        const depositTd = document.createElement('td');
        depositTd.className = 'px-3 py-2 text-right text-emerald-600 font-semibold';
        depositTd.textContent = row.amount > 0 ? formatCurrency(row.amount) : '';

        const balanceTd = document.createElement('td');
        balanceTd.className = 'px-3 py-2 text-right text-gray-700 whitespace-nowrap font-semibold';
        balanceTd.textContent = row.showBalance && Number.isFinite(row.runningBalance)
          ? formatCurrency(row.runningBalance)
          : '';

        const actionsTd = document.createElement('td');
        actionsTd.className = 'px-3 py-2 text-right no-copy';
        const editBtn = document.createElement('button');
        editBtn.type = 'button';
        editBtn.className = 'text-indigo-600 hover:text-indigo-800 text-xs font-semibold';
        editBtn.textContent = 'Edit';
        editBtn.addEventListener('click', (ev) => {
          ev.stopPropagation();
          if (Number.isInteger(originalIndex)) openTransactionModal('edit', originalIndex);
        });
        actionsTd.appendChild(editBtn);

        tr.appendChild(selectTd);
        tr.appendChild(dateTd);
        tr.appendChild(descTd);
        extraTds.forEach(td => tr.appendChild(td));
        tr.appendChild(withdrawTd);
        tr.appendChild(depositTd);
        tr.appendChild(balanceTd);
        tr.appendChild(actionsTd);

        tr.addEventListener('click', (ev) => {
          const tag = (ev.target.tagName || '').toUpperCase();
          if (tag === 'INPUT' || tag === 'BUTTON' || tag === 'A') return;
          if (!canSelect) return;
          const nextState = !selectionSet.has(originalIndex);
          handleMonthlySelection(originalIndex, nextState);
        });

        bodyEl.appendChild(tr);
      });

      if (entry.rows.length === 0) {
        const colSpan = 7 + extraFields.length;
        bodyEl.innerHTML = `<tr><td class="px-3 py-3 text-center text-gray-400" colspan="${colSpan}">No transactions available for this month.</td></tr>`;
      }
    }

    if (beginningEl) beginningEl.textContent = formatCurrency(entry.beginningBalance || 0);
    if (endingEl) endingEl.textContent = formatCurrency(entry.endingBalance || 0);

    if (paymentsEl) paymentsEl.textContent = formatCurrency(entry.paymentsTotal || 0);
    if (paymentsCountEl) {
      const count = Number(entry.paymentsCount) || 0;
      paymentsCountEl.textContent = `${count} ${count === 1 ? 'payment' : 'payments'}`;
    }

    if (depositsEl) depositsEl.textContent = formatCurrency(entry.depositsTotal || 0);
    if (depositsCountEl) {
      const count = Number(entry.depositsCount) || 0;
      depositsCountEl.textContent = `${count} ${count === 1 ? 'deposit' : 'deposits'}`;
    }

    updateMonthlyControls();
  }

  function openTransactionModal(mode, transactionIndex = null) {
    if (!mode) return;
    if (mode === 'add' && !state.selectedReconcileMonthKey) {
      showMessage('Select a month first.', 'warning', 2500);
      return;
    }
    const modal = document.getElementById('transaction-modal');
    if (!modal) return;
    const title = document.getElementById('transaction-modal-title');
    const dateInput = document.getElementById('transaction-date');
    const descriptionInput = document.getElementById('transaction-description');
    const amountInput = document.getElementById('transaction-amount');

    state.transactionModalMode = mode;
    state.transactionModalIndex = transactionIndex;
    state.transactionModalMonthKey = state.selectedReconcileMonthKey;

    if (mode === 'edit') {
      if (!Number.isInteger(transactionIndex) || !state.transactions[transactionIndex]) {
        showMessage('Could not locate the selected transaction.', 'error', 3000);
        return;
      }
      const tx = state.transactions[transactionIndex];
      if (title) title.textContent = 'Edit Transaction';
      if (dateInput) dateInput.value = formatDateForInput(tx['Cleared Date'] ?? tx['Date'] ?? '');
      const desc = resolveFieldValue(tx, 'Description') || resolveFieldValue(tx, 'Memo') || getTransactionCopyDescription(tx);
      if (descriptionInput) descriptionInput.value = desc || '';
      const amount = parseAmount(tx['Amount'] ?? tx['amount'] ?? tx.Amount ?? 0);
      if (amountInput) amountInput.value = Number.isFinite(amount) ? amount.toFixed(2) : '';
    } else {
      if (title) title.textContent = 'Add Transaction';
      let defaultIsoDate = '';
      const key = state.selectedReconcileMonthKey;
      if (key && /^(\d{4})-(\d{2})$/.test(key)) {
        const [, year, month] = key.match(/^(\d{4})-(\d{2})$/);
        defaultIsoDate = `${year}-${month}-01`;
      } else {
        const today = new Date();
        defaultIsoDate = `${today.getFullYear()}-${String(today.getMonth() + 1).padStart(2, '0')}-${String(today.getDate()).padStart(2, '0')}`;
      }
      if (dateInput) dateInput.value = defaultIsoDate;
      if (descriptionInput) descriptionInput.value = '';
      if (amountInput) amountInput.value = '';
    }

    modal.classList.remove('hidden');
    modal.style.display = 'flex';
    if (dateInput) dateInput.focus();
  }

  function closeTransactionModal() {
    const modal = document.getElementById('transaction-modal');
    if (!modal) return;
    modal.classList.add('hidden');
    modal.style.display = 'none';
    state.transactionModalMode = null;
    state.transactionModalIndex = null;
    state.transactionModalMonthKey = null;
  }

  function getMonthKeyFromDate(raw) {
    const date = coerceDateValue(raw);
    if (!date) return null;
    return `${date.getFullYear()}-${String(date.getMonth() + 1).padStart(2, '0')}`;
  }

  function saveTransactionModal() {
    const mode = state.transactionModalMode;
    if (!mode) return;
    const dateInput = document.getElementById('transaction-date');
    const descriptionInput = document.getElementById('transaction-description');
    const amountInput = document.getElementById('transaction-amount');
    if (!dateInput || !descriptionInput || !amountInput) return;

    const rawDate = dateInput.value;
    const description = descriptionInput.value.trim();
    const rawAmount = amountInput.value;
    if (!rawDate) {
      showMessage('Enter a transaction date.', 'warning', 2500);
      return;
    }
    if (!rawAmount || Number.isNaN(Number(rawAmount))) {
      showMessage('Enter a valid amount.', 'warning', 2500);
      return;
    }
    const amount = Number(rawAmount);
    if (!Number.isFinite(amount) || Math.abs(amount) < 1e-9) {
      showMessage('Amount cannot be zero.', 'warning', 2500);
      return;
    }
    const displayDate = normalizeInputDate(rawDate);
    if (!displayDate) {
      showMessage('Invalid date.', 'error', 3000);
      return;
    }
    const newMonthKey = getMonthKeyFromDate(displayDate);

    if (mode === 'edit') {
      const idx = state.transactionModalIndex;
      if (!Number.isInteger(idx) || !state.transactions[idx]) {
        showMessage('Could not locate the selected transaction.', 'error', 3000);
        closeTransactionModal();
        return;
      }
      const tx = state.transactions[idx];
      tx['Date'] = displayDate;
      tx['Cleared Date'] = displayDate;
      if (Object.prototype.hasOwnProperty.call(tx, 'Transaction Date')) tx['Transaction Date'] = displayDate;
      if (Object.prototype.hasOwnProperty.call(tx, 'Transactions Date')) tx['Transactions Date'] = displayDate;
      if (Object.prototype.hasOwnProperty.call(tx, 'Txn Date')) tx['Txn Date'] = displayDate;
      if (Object.prototype.hasOwnProperty.call(tx, 'Posted Date')) tx['Posted Date'] = displayDate;
      tx['Description'] = description;
      if (Object.prototype.hasOwnProperty.call(tx, 'Memo')) tx['Memo'] = description;
      tx['Amount'] = amount;
      if (Object.prototype.hasOwnProperty.call(tx, 'amount')) tx['amount'] = amount;
    } else if (mode === 'add') {
      const newTx = {
        'Date': displayDate,
        'Cleared Date': displayDate,
        'Transaction Date': displayDate,
        'Transactions Date': displayDate,
        'Txn Date': displayDate,
        'Description': description,
        'Memo': description,
        'Payee': description,
        'Amount': amount,
        'amount': amount,
        'Schedule C Category': ''
      };
      state.transactions.push(newTx);
    }

    if (newMonthKey) {
      state.selectedReconcileMonthKey = newMonthKey;
    }

    state.selectedTxIndexes.clear();
    state.anchorIndex = null;
    state.anchorContext = null;
    state.selectionContext = null;
    if (state.selectedMonthlyTxIndexes) state.selectedMonthlyTxIndexes.clear();

    closeTransactionModal();
    renderUnassigned();
    renderAssigned();
    updateReports();
    refreshAllDropdowns();

    const message = mode === 'edit' ? 'Transaction updated.' : 'Transaction added.';
    showMessage(message, 'success', 2500);
  }

  function formatAmountString(value) {
    if (!Number.isFinite(value)) return '0.00';
    const clean = Math.abs(value) < 0.00001 ? 0 : value;
    return clean.toFixed(2);
  }

  async function deleteSelectedMonthlyTransactions() {
    showMessage('Processing selected transactions...', 'info', 1500);
    const selected = state.selectedMonthlyTxIndexes instanceof Set
      ? Array.from(state.selectedMonthlyTxIndexes)
      : [];
    const normalizedIndexes = selected
      .map(idx => (typeof idx === 'string' ? Number(idx) : idx))
      .filter(idx => Number.isInteger(idx) && idx >= 0);
    if (normalizedIndexes.length === 0) {
      showMessage('Select at least one monthly transaction to delete.', 'warning', 2500);
      return;
    }
    const uniqueIndexes = Array.from(new Set(normalizedIndexes)).sort((a, b) => a - b);
    const confirmText = uniqueIndexes.length === 1
      ? 'Delete the selected transaction?'
      : `Delete ${uniqueIndexes.length} selected transactions?`;
    const ok = await showConfirm(confirmText);
    if (!ok) return;

    uniqueIndexes.sort((a, b) => b - a).forEach(idx => {
      if (idx >= 0 && idx < state.transactions.length) {
        state.transactions.splice(idx, 1);
      }
    });

    state.selectedMonthlyTxIndexes.clear();
    state.selectedTxIndexes.clear();
    state.anchorIndex = null;
    state.anchorContext = null;
    state.selectionContext = null;

    renderUnassigned();
    renderAssigned();
    updateReports();
    refreshAllDropdowns();
    renderReconcileDetail();
    updateMonthlyControls();
    showMessage(`Deleted ${uniqueIndexes.length} transaction${uniqueIndexes.length === 1 ? '' : 's'}.`, 'success', 2500);
  }

  function switchMonthlyDebitCredit() {
    const indexes = Array.from(state.selectedMonthlyTxIndexes).filter(idx => Number.isInteger(idx));
    if (!indexes.length) {
      showMessage('Select at least one monthly transaction first.', 'warning', 2500);
      return;
    }
    const depositFields = ['Deposit', 'Deposits', 'Money In', 'Credit', 'CREDIT', 'credit'];
    const withdrawalFields = ['Withdrawal', 'Withdrawals', 'Money Out', 'Debit', 'DEBIT', 'Charge', 'charge'];
    indexes.forEach(idx => {
      const tx = state.transactions[idx];
      if (!tx) return;
      let currentAmount = parseAmount(tx['Amount'] ?? tx['amount'] ?? tx.Amount ?? 0);
      if (!Number.isFinite(currentAmount) || Math.abs(currentAmount) < 1e-9) {
        const creditField = depositFields.find(field => Object.prototype.hasOwnProperty.call(tx, field) && parseAmount(tx[field]) !== 0);
        const debitField = withdrawalFields.find(field => Object.prototype.hasOwnProperty.call(tx, field) && parseAmount(tx[field]) !== 0);
        if (creditField) currentAmount = parseAmount(tx[creditField]);
        else if (debitField) currentAmount = -parseAmount(tx[debitField]);
      }
      if (!Number.isFinite(currentAmount)) return;
      const newAmount = -currentAmount;
      const amountString = formatAmountString(newAmount);
      tx['Amount'] = amountString;
      if (Object.prototype.hasOwnProperty.call(tx, 'amount')) tx['amount'] = amountString;

      const setDirectional = (fields, absValue) => {
        fields.forEach(field => {
          if (Object.prototype.hasOwnProperty.call(tx, field)) {
            tx[field] = absValue > 0.00001 ? formatAmountString(absValue) : '';
          }
        });
      };

      const positiveAmount = Math.abs(newAmount);
      setDirectional(depositFields, newAmount > 0 ? positiveAmount : 0);
      setDirectional(withdrawalFields, newAmount < 0 ? positiveAmount : 0);
    });

    updateReports();
    renderUnassigned();
    renderAssigned();
    showMessage(`Switched debit/credit for ${indexes.length} transaction${indexes.length === 1 ? '' : 's'} in this month.`, 'success', 2500);
  }
  function updateReconcilePreview() {
    const beginningInput = document.getElementById('reconcile-beginning-input');
    const statementInput = document.getElementById('reconcile-statement-input');
    if (!beginningInput || !statementInput) return;
    const beginning = Number(beginningInput.value) || 0;
    const statement = Number(statementInput.value) || 0;
    const difference = statement - beginning;
    const previewBeginning = document.getElementById('reconcile-preview-beginning');
    const previewStatement = document.getElementById('reconcile-preview-statement');
    const previewDifference = document.getElementById('reconcile-preview-difference');
    if (previewBeginning) previewBeginning.textContent = formatCurrency(beginning);
    if (previewStatement) previewStatement.textContent = formatCurrency(statement);
    if (previewDifference) {
      previewDifference.textContent = formatCurrency(difference);
      const base = 'font-semibold';
      const tone = Math.abs(difference) < 0.01 ? ' text-emerald-600' : difference > 0 ? ' text-amber-600' : ' text-rose-600';
      previewDifference.className = base + tone;
    }
  }

  function openReconcileModal() {
    const modal = document.getElementById('reconcile-modal');
    if (!modal) return;
    const beginningInput = document.getElementById('reconcile-beginning-input');
    const statementInput = document.getElementById('reconcile-statement-input');
    if (beginningInput) beginningInput.value = Number.isFinite(Number(state.beginningBalance)) ? Number(state.beginningBalance).toFixed(2) : '';
    if (statementInput) statementInput.value = Number.isFinite(Number(state.statementBalance)) ? Number(state.statementBalance).toFixed(2) : '';
    updateReconcilePreview();
    modal.classList.remove('hidden');
    modal.style.display = 'flex';
  }

  function closeReconcileModal() {
    const modal = document.getElementById('reconcile-modal');
    if (!modal) return;
    modal.classList.add('hidden');
    modal.style.display = 'none';
  }

  function fallbackCopyToClipboard(text) {
    try {
      const textarea = document.createElement('textarea');
      textarea.value = text;
      textarea.setAttribute('readonly', '');
      textarea.style.position = 'absolute';
      textarea.style.left = '-9999px';
      document.body.appendChild(textarea);
      textarea.select();
      const succeeded = document.execCommand('copy');
      document.body.removeChild(textarea);
      return succeeded;
    } catch (_err) {
      return false;
    }
  }

  async function copySelectedTransactions() {
    if (!state.selectedTxIndexes || state.selectedTxIndexes.size === 0) {
      showMessage('Select at least one transaction to copy.', 'warning', 2500);
      return;
    }
    const indexes = Array.from(state.selectedTxIndexes).filter(idx => Number.isInteger(idx)).sort((a, b) => a - b);
    if (indexes.length === 0) {
      showMessage('Selected transactions did not contain copyable data.', 'warning', 2500);
      return;
    }
    const lines = [['Date', 'Description', 'Amount']];
    indexes.forEach(idx => {
      const tx = state.transactions[idx];
      if (!tx) return;
      const date = getTransactionCopyDate(tx);
      const description = getTransactionCopyDescription(tx);
      const rawAmount = tx['Amount'] ?? tx['amount'] ?? tx.Amount ?? '';
      const amountNumber = parseAmount(rawAmount);
      const amountDisplay = Number.isFinite(amountNumber) ? formatCurrency(amountNumber) : sanitizeClipboardValue(rawAmount);
      lines.push([
        sanitizeClipboardValue(date),
        sanitizeClipboardValue(description),
        sanitizeClipboardValue(amountDisplay)
      ]);
    });
    if (lines.length === 1) {
      showMessage('Selected transactions did not contain copyable data.', 'warning', 2500);
      return;
    }
    const text = lines.map(cols => cols.join('\t')).join('\r\n');
    const attemptClipboardWrite = async () => {
      if (navigator.clipboard && typeof navigator.clipboard.writeText === 'function') {
        try {
          await navigator.clipboard.writeText(text);
          return true;
        } catch (_err) {
          return false;
        }
      }
      return false;
    };
    const clipboardSuccess = (await attemptClipboardWrite()) || fallbackCopyToClipboard(text);
    if (clipboardSuccess) {
      showMessage(`Copied ${lines.length - 1} transaction${lines.length - 1 === 1 ? '' : 's'} to clipboard.`, 'success', 2500);
    } else {
      showMessage('Unable to copy the selected transactions.', 'error', 3000);
    }
  }

  // === Reclassify flow ===
  document.getElementById('reclassify-button').addEventListener('click', () => {
    // open COA modal with selection
    if (state.selectedTxIndexes.size === 0) return;
    openCoaModal();
  });

  // Deselect button clears current selection
  document.getElementById('deselect-filters').addEventListener('click', () => {
    state.selectedTxIndexes.clear();
    state.anchorIndex = null;
    state.anchorContext = null;
    state.selectionContext = null;
    // clear the assigned filter only when user explicitly clicks Deselect
    state.assignedFilter = null;
    renderUnassigned(); renderAssigned();
    updateSelectionUI();
  });

  // Assigned tab reclassify header button
  document.getElementById('assigned-reclassify-button').addEventListener('click', () => {
    if (state.selectedTxIndexes.size === 0) return;
    openCoaModal();
  });

  function openCoaModal(preTx=null, preIdx=null) {
    const modal = document.getElementById('coa-modal');
    modal.classList.remove('hidden'); modal.style.display='flex';
    const select = document.getElementById('coa-select');
    select.value = '';
    // preselect account if provided
    if (preTx && preTx['Schedule C Category']) select.value = preTx['Schedule C Category'];
  }

  document.getElementById('coa-cancel').addEventListener('click', () => {
    const modal = document.getElementById('coa-modal'); modal.classList.add('hidden'); modal.style.display='none';
  });

  document.getElementById('coa-save').addEventListener('click', () => {
    const select = document.getElementById('coa-select');
    const account = select.value;
    if (!account) { showMessage('Choose an account first', 'warning', 2500); return; }
    // apply to selected transactions
    if (state.selectedTxIndexes.size > 0) {
      Array.from(state.selectedTxIndexes).forEach(idx => {
        const tx = state.transactions[idx];
        if (tx) tx['Schedule C Category'] = account;
      });
      // after apply, clear selection
      state.selectedTxIndexes.clear();
      state.anchorIndex = null;
      state.anchorContext = null;
      state.selectionContext = null;
      renderUnassigned(); renderAssigned(); updateReports(); refreshAllDropdowns();
    }
    // close modal
    document.getElementById('coa-modal').classList.add('hidden'); document.getElementById('coa-modal').style.display='none';
  });

  // === COA management ===
  document.getElementById('add-coa').addEventListener('click', () => {
    document.getElementById('add-coa-modal').classList.remove('hidden'); document.getElementById('add-coa-modal').style.display='flex';
  });
  document.getElementById('add-coa-cancel').addEventListener('click', () => {
    document.getElementById('add-coa-modal').classList.add('hidden'); document.getElementById('add-coa-modal').style.display='none';
  });
  document.getElementById('add-coa-save').addEventListener('click', () => {
    const name = document.getElementById('new-account-name').value.trim();
    const type = document.getElementById('new-account-type').value;
    const desc = document.getElementById('new-account-desc').value.trim();
    if (!name) { showMessage('Name required', 'warning', 2500); return; }
    // infer type if blank
    const acct = { 'Account Name': name, 'Account Type': type || inferAccountType(name)[1], 'Description': desc };
    state.coaTable.push(acct);
    document.getElementById('add-coa-modal').classList.add('hidden'); document.getElementById('add-coa-modal').style.display='none';
    renderCoa(); refreshAllDropdowns(); updateReports();
  });

  document.getElementById('merge-coa').addEventListener('click', async () => {
    // find duplicates by lower-case name
    const map = new Map();
    state.coaTable.forEach(a => {
      const k = a['Account Name'].toLowerCase().trim();
      if (!map.has(k)) map.set(k, []);
      map.get(k).push(a);
    });
    const duplicates = Array.from(map.entries()).filter(([k,v]) => v.length > 1);
    if (duplicates.length === 0) { showMessage('No duplicates found','info',2500); return; }
    const ok = await showConfirm('Merge duplicates? This will keep first and discard later entries.');
    if (!ok) return;
    const newTable = [];
    map.forEach((arr) => {
      newTable.push(arr[0]);
    });
    state.coaTable = newTable;
    renderCoa(); refreshAllDropdowns(); updateReports();
  });

  let coaHeadersInitialized = false;

  function setCoaSort(column) {
    if (!column) return;
    const sortState = state.coaSort || (state.coaSort = { column: null, direction: 'asc' });
    if (sortState.column === column) {
      sortState.direction = sortState.direction === 'asc' ? 'desc' : 'asc';
    } else {
      sortState.column = column;
      sortState.direction = 'asc';
    }
    renderCoa();
  }

  function updateCoaSortIndicators() {
    const headers = document.querySelectorAll('#coa-table thead [data-coa-sort]');
    headers.forEach(th => {
      const column = th.dataset.coaSort;
      const indicator = th.querySelector('[data-coa-sort-indicator]');
      if (state.coaSort && state.coaSort.column === column) {
        const dirChar = state.coaSort.direction === 'desc' ? '' : '';
        if (indicator) {
          indicator.textContent = dirChar;
          indicator.classList.remove('opacity-0');
        }
        th.setAttribute('aria-sort', state.coaSort.direction === 'desc' ? 'descending' : 'ascending');
        th.classList.add('text-indigo-600');
      } else {
        if (indicator) {
          indicator.textContent = '';
          indicator.classList.add('opacity-0');
        }
        th.setAttribute('aria-sort', 'none');
        th.classList.remove('text-indigo-600');
      }
    });
  }

  function initCoaSortHeaders() {
    if (coaHeadersInitialized) return;
    const headers = document.querySelectorAll('#coa-table thead [data-coa-sort]');
    if (!headers.length) return;
    headers.forEach(th => {
      if (!th.hasAttribute('tabindex')) th.tabIndex = 0;
      const activate = () => setCoaSort(th.dataset.coaSort);
      th.addEventListener('click', activate);
      th.addEventListener('keydown', (ev) => {
        if (ev.key === 'Enter' || ev.key === ' ') {
          ev.preventDefault();
          activate();
        }
      });
    });
    coaHeadersInitialized = true;
    updateCoaSortIndicators();
  }

  function renderCoa() {
    const tbody = document.getElementById('coa-body');
    if (!tbody) return;
    tbody.innerHTML = '';
    const rows = Array.isArray(state.coaTable)
      ? state.coaTable.map((account, originalIndex) => ({ account, originalIndex }))
      : [];

    if (state.coaSort && state.coaSort.column) {
      const column = state.coaSort.column;
      const direction = state.coaSort.direction === 'desc' ? -1 : 1;
      const normalize = (value) => {
        if (value === null || value === undefined) return '';
        return value.toString().trim().toLowerCase();
      };
      rows.sort((a, b) => {
        const valA = normalize(a.account[column]);
        const valB = normalize(b.account[column]);
        const compare = valA.localeCompare(valB, undefined, { numeric: true, sensitivity: 'base' });
        if (compare !== 0) return compare * direction;
        const fallback = normalize(a.account['Account Name']).localeCompare(
          normalize(b.account['Account Name']),
          undefined,
          { numeric: true, sensitivity: 'base' }
        );
        if (fallback !== 0) return fallback * direction;
        return a.originalIndex - b.originalIndex;
      });
    }

    rows.forEach(({ account }) => {
      const tr = document.createElement('tr'); tr.className='border-b hover:bg-gray-50';
      const nameTd = document.createElement('td');
      nameTd.className = 'px-3 py-2';
      nameTd.contentEditable = true;
      nameTd.textContent = account['Account Name'];
      nameTd.addEventListener('blur', async () => {
        const originalRaw = (account['Account Name'] ?? '').toString();
        const storedName = originalRaw.trim();
        const proposed = (nameTd.textContent || '').trim();
        if (!proposed) {
          nameTd.textContent = storedName;
          showMessage('Account name cannot be empty.', 'warning', 2500);
          return;
        }
        if (proposed === storedName && originalRaw === storedName) {
          nameTd.textContent = storedName;
          return;
        }
        const result = await applyAccountRename(account, proposed);
        if (!result || result.status === 'failed' || result.status === 'cancelled') {
          nameTd.textContent = storedName;
          return;
        }
        if (result.status === 'merged') {
          renderCoa();
          refreshAllDropdowns();
          updateReports();
          return;
        }
        nameTd.textContent = account['Account Name'];
        refreshAllDropdowns();
        updateReports();
        showMessage(`Renamed account to ${account['Account Name']}`, 'success', 2000);
      });
      const typeTd = document.createElement('td'); typeTd.className='px-3 py-2';
      const typeSelect = document.createElement('select'); typeSelect.className='rounded border px-2 py-1';
      ['Checking or savings','Credit card account','Cost of goods sold','Fixed asset','Capital / Equity','Expense','Income','Other expense','Other income','Long term liability','Other current liability'].forEach(opt => { const o = document.createElement('option'); o.value=opt; o.textContent=opt; if (account['Account Type']===opt) o.selected=true; typeSelect.appendChild(o); });
      typeSelect.addEventListener('change', () => { account['Account Type'] = typeSelect.value; updateReports(); });
      typeTd.appendChild(typeSelect);
      const descTd = document.createElement('td'); descTd.className='px-3 py-2'; descTd.contentEditable=true; descTd.textContent = account['Description'] || '';
      descTd.addEventListener('blur', () => { account['Description'] = descTd.textContent; });
      tr.appendChild(nameTd); tr.appendChild(typeTd); tr.appendChild(descTd);
      tbody.appendChild(tr);
    });

    updateCoaSortIndicators();
  }

  // === Reports (Real-Time) ===
  function updateReports() {
    const income = {};
    const cogs = {};
    const expense = {};
    const balanceBuckets = {
      asset: Object.create(null),
      liability: Object.create(null),
      equity: Object.create(null)
    };
    const rawBalanceTotals = { asset: 0, liability: 0, equity: 0 };
    let totalIncome = 0; let totalCogs = 0; let totalExpense = 0;
    state.transactions.filter(t => t['Schedule C Category']).forEach(tx => {
      const category = tx['Schedule C Category'];
      const acct = state.coaTable.find(a => a['Account Name'] === category);
      const type = acct ? acct['Account Type'] : '';
      const amt = parseAmount(tx['Amount'] ?? tx['amount'] ?? 0);
      const classification = classifyAccountType(type, category);
      const lowerType = (type || '').toString().toLowerCase();
      const lowerCategory = (category || '').toString().toLowerCase();

      const addBalance = bucket => {
        const bucketStore = balanceBuckets[bucket];
        bucketStore[category] = (bucketStore[category] || 0) + amt;
        rawBalanceTotals[bucket] += amt;
      };

      const recordExpense = () => {
        const value = Number.isFinite(amt) ? amt : 0;
        if (lowerType.includes('cost') || lowerType.includes('cogs') || lowerCategory.includes('cost of goods') || lowerCategory.includes('cogs')) {
          cogs[category] = (cogs[category] || 0) + value;
          totalCogs += value;
        } else {
          expense[category] = (expense[category] || 0) + value;
          totalExpense += value;
        }
      };

      if (classification === 'income') {
        income[category] = (income[category] || 0) + amt;
        totalIncome += amt;
      } else if (classification === 'expense' || classification === 'other' || classification === 'cogs') {
        recordExpense();
      } else if (classification === 'asset') {
        addBalance('asset');
      } else if (classification === 'liability') {
        addBalance('liability');
      } else if (classification === 'equity') {
        addBalance('equity');
      } else {
        recordExpense();
      }
    });

    const totalExpCombined = totalCogs + totalExpense;
    const displayedExpenses = Math.abs(totalExpCombined);
    const net = totalIncome - displayedExpenses;
    const retainedName = 'Retained Earnings';
    if (Math.abs(net) > 0.00001) {
      balanceBuckets.equity[retainedName] = (balanceBuckets.equity[retainedName] || 0) + net;
      rawBalanceTotals.equity += net;
    }

    const beginningBalance = Number(state.beginningBalance) || 0;
    if (Math.abs(beginningBalance) > 0.00001) {
      const openingName = 'Opening Equity';
      balanceBuckets.equity[openingName] = (balanceBuckets.equity[openingName] || 0) + beginningBalance;
      rawBalanceTotals.equity += beginningBalance;
    }

    const statementBalance = Number(state.statementBalance) || 0;
    if (Math.abs(statementBalance) > 0.00001) {
      const endingName = 'Ending Balance';
      balanceBuckets.asset[endingName] = (balanceBuckets.asset[endingName] || 0) + statementBalance;
      rawBalanceTotals.asset += statementBalance;
    }

    const toBalanceRows = (bucket, options = {}) => {
      const preserveSign = !!options.preserveSign;
      const preserveNames = Array.isArray(options.preserveNames)
        ? new Set(options.preserveNames.map(name => (name || '').toString().toLowerCase()))
        : null;
      return Object.entries(bucket)
        .map(([name, raw]) => {
          const normalizedName = (name || '').toString().toLowerCase();
          const keepSign = preserveSign || (preserveNames && preserveNames.has(normalizedName));
          const value = keepSign ? raw : Math.abs(raw);
          return { name, rawTotal: raw, displayTotal: value };
        })
        .filter(row => Math.abs(row.displayTotal) > 0.00001)
      .sort((a, b) => a.name.localeCompare(b.name));
    };

    const balanceData = {
      assets: toBalanceRows(balanceBuckets.asset, { preserveNames: ['Ending Balance'] }),
      liabilities: toBalanceRows(balanceBuckets.liability, { preserveSign: true }),
      equity: toBalanceRows(balanceBuckets.equity, { preserveSign: true }),
      rawAssets: rawBalanceTotals.asset,
      rawLiabilities: rawBalanceTotals.liability,
      rawEquity: rawBalanceTotals.equity
    };
    balanceData.totalAssets = balanceData.assets.reduce((sum, row) => sum + row.displayTotal, 0);
    balanceData.totalLiabilities = balanceData.liabilities.reduce((sum, row) => sum + row.displayTotal, 0);
    balanceData.totalEquity = balanceData.equity.reduce((sum, row) => sum + row.displayTotal, 0);
    balanceData.displayLiabilitiesEquity = balanceData.totalLiabilities + balanceData.totalEquity;
    balanceData.balanceDifference = balanceData.totalAssets - balanceData.displayLiabilitiesEquity;
    balanceData.rawBalanceDifference = balanceData.rawAssets - (balanceData.rawLiabilities + balanceData.rawEquity);

    renderReportTables(income, cogs, expense);
    document.getElementById('total-income').textContent = formatCurrency(totalIncome);
    const totalExpenseEl = document.getElementById('total-expense');
    if (totalExpenseEl) {
      totalExpenseEl.textContent = formatCurrency(displayedExpenses);
      totalExpenseEl.className = 'text-red-600 text-lg font-bold';
    }
    const netEl = document.getElementById('net-profit'); netEl.textContent = formatCurrency(net);
    netEl.className = net >= 0 ? 'text-green-600 text-lg font-bold' : 'text-red-600 text-lg font-bold';

    renderBalanceSheet(balanceData);
    setReportView(state.reportView);
    updateReconcileView();
  }

  function renderReportTables(incomeObj, cogsObj, expenseObj) {
    const incTable = document.getElementById('report-income'); const expTable = document.getElementById('report-expense');
    incTable.innerHTML = '<tr><th class="text-left px-2 py-1">ACCOUNT</th><th class="text-right px-2 py-1">TOTAL</th></tr>';
    Object.entries(incomeObj).sort((a,b)=>b[1]-a[1]).forEach(([k,v]) => incTable.innerHTML += `<tr class="hover:bg-gray-50 cursor-pointer"><td class="px-2 py-1">${k}</td><td class="px-2 py-1 text-right text-green-600">${formatCurrency(v)}</td></tr>`);

    // Expenses: render COGS first then other expenses
    expTable.innerHTML = '<tr><th class="text-left px-2 py-1">ACCOUNT</th><th class="text-right px-2 py-1">TOTAL</th></tr>';
    const cogsEntries = Object.entries(cogsObj).sort((a,b)=>b[1]-a[1]);
    const expenseEntries = Object.entries(expenseObj).sort((a,b)=>b[1]-a[1]);

    if (cogsEntries.length > 0) {
      // section header for COGS
      expTable.innerHTML += `<tr class="bg-slate-50"><td class="px-2 py-1 font-medium" colspan="2">Cost of Goods Sold</td></tr>`;
      cogsEntries.forEach(([k,v]) => {
        const tone = v >= 0 ? 'text-emerald-600' : 'text-red-600';
        const displayValue = Math.abs(v);
        expTable.innerHTML += `<tr class="hover:bg-gray-50 cursor-pointer"><td class="px-2 py-1">${k}</td><td class="px-2 py-1 text-right font-semibold ${tone}">${formatCurrency(displayValue)}</td></tr>`;
      });
    }

    if (expenseEntries.length > 0) {
      // section header for other expenses
      expTable.innerHTML += `<tr class="bg-slate-50"><td class="px-2 py-1 font-medium" colspan="2">Expenses</td></tr>`;
      expenseEntries.forEach(([k,v]) => {
        const tone = v >= 0 ? 'text-emerald-600' : 'text-red-600';
        const displayValue = Math.abs(v);
        expTable.innerHTML += `<tr class="hover:bg-gray-50 cursor-pointer"><td class="px-2 py-1">${k}</td><td class="px-2 py-1 text-right font-semibold ${tone}">${formatCurrency(displayValue)}</td></tr>`;
      });
    }

    // clicking a row filters assigned
  Array.from(incTable.querySelectorAll('tr')).forEach((tr,i)=>{ if(i===0) return; tr.addEventListener('click', ()=>{ const acc = tr.children[0].textContent; state.assignedFilter = acc; document.querySelector('[data-tab="assigned"]').click(); renderAssigned(); }); });
  Array.from(expTable.querySelectorAll('tr')).forEach((tr,i)=>{ if(i===0) return; tr.addEventListener('click', ()=>{ const acc = tr.children[0].textContent; state.assignedFilter = acc; document.querySelector('[data-tab="assigned"]').click(); renderAssigned(); }); });
  }

  function renderBalanceSheet(balance) {
    const safe = balance || {};
    const assets = safe.assets || [];
    const liabilities = safe.liabilities || [];
    const equity = safe.equity || [];
    const renderBucket = (tbodyId, rows) => {
      const tbody = document.getElementById(tbodyId);
      if (!tbody) return;
      tbody.innerHTML = '';
      if (!rows.length) {
        const tr = document.createElement('tr');
        tr.innerHTML = `<td class="px-3 py-2 text-sm text-gray-400" colspan="2">No accounts found.</td>`;
        tbody.appendChild(tr);
        return;
      }
      rows.forEach(row => {
        const tr = document.createElement('tr');
        const isActive = state.assignedFilter === row.name;
        tr.className = `cursor-pointer transition ${isActive ? 'bg-indigo-50' : 'hover:bg-gray-50'}`;
        tr.innerHTML = `
          <td class="px-3 py-2 text-sm text-gray-700">${row.name}</td>
          <td class="px-3 py-2 text-sm text-right font-mono font-semibold text-slate-700">${formatCurrency(row.displayTotal)}</td>
        `;
        tr.addEventListener('click', () => {
          state.assignedFilter = row.name;
          const assignedTab = document.querySelector('[data-tab="assigned"]');
          if (assignedTab) assignedTab.click();
          renderAssigned();
        });
        tbody.appendChild(tr);
      });
    };

    renderBucket('balance-assets-body', assets);
    renderBucket('balance-liabilities-body', liabilities);
    renderBucket('balance-equity-body', equity);

    const setText = (id, value) => {
      const el = document.getElementById(id);
      if (el) el.textContent = formatCurrency(value || 0);
    };

    setText('balance-assets-total', safe.totalAssets || 0);
    setText('balance-liabilities-total', safe.totalLiabilities || 0);
    setText('balance-equity-total', safe.totalEquity || 0);

    setText('balance-total-assets', safe.totalAssets || 0);
    const liabilitiesEquityDisplay = safe.displayLiabilitiesEquity !== undefined
      ? safe.displayLiabilitiesEquity
      : (safe.totalLiabilities || 0) + (safe.totalEquity || 0);
    setText('balance-total-liabilities-equity', liabilitiesEquityDisplay);

    const diff = safe.balanceDifference ?? 0;
    const hasBalanceData = assets.length > 0 || liabilities.length > 0 || equity.length > 0;
    const diffAmount = document.getElementById('balance-difference');
    if (diffAmount) {
      diffAmount.textContent = formatCurrency(diff);
      if (!hasBalanceData) diffAmount.className = 'mt-1 text-lg font-bold text-gray-800';
      else diffAmount.className = `mt-1 text-lg font-bold ${Math.abs(diff) < 0.01 ? 'text-emerald-600' : diff > 0 ? 'text-amber-600' : 'text-rose-600'}`;
    }
    const diffCard = document.getElementById('balance-diff-card');
  if (diffCard) {
      if (!hasBalanceData) diffCard.className = 'rounded-lg border border-slate-200 bg-white px-4 py-3 shadow-sm';
      else {
        let toneClass = 'border-rose-200 bg-rose-50';
        if (Math.abs(diff) < 0.01) toneClass = 'border-emerald-200 bg-emerald-50';
        else if (diff > 0) toneClass = 'border-amber-200 bg-amber-50';
        diffCard.className = `rounded-lg px-4 py-3 shadow-sm border ${toneClass}`;
      }
    }
  }

  function setReportView(view) {
    const desired = view || 'pl';
    state.reportView = desired;
    document.querySelectorAll('.report-tab-btn').forEach(btn => {
      const active = btn.dataset.reportTab === desired;
      btn.classList.toggle('bg-white', active);
      btn.classList.toggle('shadow', active);
      btn.classList.toggle('text-indigo-600', active);
      btn.classList.toggle('text-gray-600', !active);
    });
    document.querySelectorAll('[data-report-content]').forEach(section => {
      section.classList.toggle('hidden', section.dataset.reportContent !== desired);
    });
  }

  // === Exports ===
  function setExportMessage(elementId, message, tone = 'info') {
    const el = document.getElementById(elementId);
    if (!el) return;
    const toneClass = tone === 'error'
      ? 'text-red-600'
      : tone === 'success'
        ? 'text-emerald-600'
        : 'text-gray-600';
    el.className = `mt-2 text-sm font-semibold ${toneClass}`;
    el.textContent = message || '';
  }

  function triggerDownload(filename, content, mime='text/plain;charset=utf-8') {
    const safeName = (filename || 'export.txt').replace(/[\\\/:*?"<>|]+/g, '_');
    const blob = new Blob([content], { type: mime });
    const url = URL.createObjectURL(blob);
    const anchor = document.createElement('a');
    anchor.href = url;
    anchor.download = safeName;
    document.body.appendChild(anchor);
    anchor.click();
    document.body.removeChild(anchor);
    setTimeout(() => URL.revokeObjectURL(url), 1000);
  }

  function triggerIifDownload(filename, content) {
    triggerDownload(filename || 'export.iif', content, 'text/plain;charset=utf-8');
  }

  function triggerBinaryDownload(filename, data, mime='application/octet-stream') {
    const safeName = (filename || 'export.bin').replace(/[\\\/:*?"<>|]+/g, '_');
    const blob = data instanceof Blob ? data : new Blob([data], { type: mime });
    const url = URL.createObjectURL(blob);
    const anchor = document.createElement('a');
    anchor.href = url;
    anchor.download = safeName;
    document.body.appendChild(anchor);
    anchor.click();
    document.body.removeChild(anchor);
    setTimeout(() => URL.revokeObjectURL(url), 1000);
  }

  function generateCoaIifContent() {
    if (!Array.isArray(state.coaTable) || state.coaTable.length === 0) {
      return { content: '', count: 0, missingTypeCount: 0 };
    }
    const seen = new Set();
    const lines = ['!ACCNT\tNAME\tACCNTTYPE\tDESC'];
    let count = 0;
    let missingTypeCount = 0;
    state.coaTable.forEach(account => {
      const rawName = (account && account['Account Name']) ? String(account['Account Name']).trim() : '';
      const key = rawName.toLowerCase();
      if (!rawName || seen.has(key)) return;
      seen.add(key);
      const name = sanitizeIifValue(rawName);
      const description = sanitizeIifValue(account['Description'] || '');
      const accntType = mapAccountTypeToIifType(account);
      if (!accntType) missingTypeCount += 1;
      lines.push(`ACCNT\t${name}\t${sanitizeIifValue(accntType)}\t${description}`);
      count += 1;
    });
    return { content: count > 0 ? lines.join('\r\n') : '', count, missingTypeCount };
  }

  function generateJournalIifContent(bankAccount) {
    const sanitizedBank = sanitizeIifValue(bankAccount);
    if (!sanitizedBank) {
      return { content: '', count: 0, skipped: { missingCategory: 0, zeroAmount: 0 } };
    }
    const lines = [
      '!TRNS\tTRNSID\tTRNSTYPE\tDATE\tACCNT\tCLASS\tAMOUNT\tDOCNUM\tMEMO',
      '!SPL\tSPLID\tTRNSTYPE\tDATE\tACCNT\tCLASS\tAMOUNT\tDOCNUM\tMEMO',
      '!ENDTRNS'
    ];
    let count = 0;
    let missingCategory = 0;
    let zeroAmount = 0;
    state.transactions.forEach(tx => {
      if (!tx) return;
      const categoryRaw = (resolveFieldValue(tx, 'Schedule C Category') || '').toString().trim();
      if (!categoryRaw) { missingCategory += 1; return; }
      const rawAmount = resolveFieldValue(tx, 'Amount');
      const amount = parseAmount(
        rawAmount !== undefined && rawAmount !== null && String(rawAmount).trim() !== ''
          ? rawAmount
          : (tx['Amount'] ?? tx['amount'] ?? tx.Amount ?? 0)
      );
      if (!Number.isFinite(amount) || Math.abs(amount) < 0.00001) { zeroAmount += 1; return; }
      const memo = buildJournalMemo(tx);
      const docFields = ['Doc Num', 'DocNum', 'Doc #', 'Check Number', 'Reference', 'Ref'];
      let docValue = '';
      for (const field of docFields) {
        const value = resolveFieldValue(tx, field);
        if (value !== undefined && value !== null && String(value).trim() !== '') {
          docValue = value;
          break;
        }
      }
      const docNum = sanitizeIifValue(docValue || '');
      const date = formatDateForIif(resolveTransactionDateValue(tx)) || '';
      const category = sanitizeIifValue(categoryRaw);
      if (!category) { missingCategory += 1; return; }
      if (amount > 0) {
        const amountStr = amount.toFixed(2);
        lines.push(`TRNS\t\tGENERAL JOURNAL\t${date}\t${sanitizedBank}\t\t${amountStr}\t${docNum}\t${memo}`);
        lines.push(`SPL\t\tGENERAL JOURNAL\t${date}\t${category}\t\t-${amountStr}\t${docNum}\t${memo}`);
      } else {
        const absAmountStr = Math.abs(amount).toFixed(2);
        lines.push(`TRNS\t\tGENERAL JOURNAL\t${date}\t${category}\t\t${absAmountStr}\t${docNum}\t${memo}`);
        lines.push(`SPL\t\tGENERAL JOURNAL\t${date}\t${sanitizedBank}\t\t${amount.toFixed(2)}\t${docNum}\t${memo}`);
      }
      lines.push('ENDTRNS');
      count += 1;
    });
    return {
      content: count > 0 ? lines.join('\r\n') : '',
      count,
      skipped: { missingCategory, zeroAmount }
    };
  }

  function compileRuleForExport(rule, index) {
    if (!rule || typeof rule !== 'object') return null;
    const amtTokenRe = /\{AMT\s*(<=|>=|<|>|==)\s*([0-9]+(?:\.[0-9]+)?)\}/i;
    const rawPattern = (rule.payee || rule.match || rule.pattern || '').toString();
    let pattern = rawPattern;
    let amtCond = null;
    const amtMatch = amtTokenRe.exec(rawPattern);
    if (amtMatch) {
      const op = amtMatch[1];
      const val = parseFloat(amtMatch[2]);
      if (!Number.isNaN(val)) {
        if (op === '<=') amtCond = x => x <= val;
        else if (op === '>=') amtCond = x => x >= val;
        else if (op === '<') amtCond = x => x < val;
        else if (op === '>') amtCond = x => x > val;
        else amtCond = x => Math.abs(x - val) < 1e-9;
      }
      pattern = pattern.replace(amtMatch[0], '').trim();
    }

    pattern = pattern.trim();
    if (!pattern) return null;

    let regex = null;
    if (pattern) {
      try {
        regex = new RegExp(pattern, 'i');
      } catch (err) {
        regex = null;
      }
    }

    const category = (rule.category || rule.Category || rule.cat || '').toString().trim();
    const direction = (rule.direction || rule.type || rule['Transaction Type'] || '').toString().trim();

    return {
      index,
      rawRule: rule,
      rawPattern,
      pattern,
      regex,
      patternLower: pattern ? pattern.toLowerCase() : '',
      category,
      categoryLower: category.toLowerCase(),
      direction,
      directionLower: direction.toLowerCase(),
      amtCond
    };
  }

  function ruleMatchesTransaction(compiledRule, desc, descLower, amount) {
    if (!compiledRule) return false;
    let matched = false;
    if (compiledRule.regex) {
      try {
        compiledRule.regex.lastIndex = 0;
        matched = compiledRule.regex.test(desc);
      } catch (err) {
        matched = false;
      }
    } else if (compiledRule.patternLower) {
      matched = descLower.includes(compiledRule.patternLower);
    }
    if (!matched) return false;

    const dir = compiledRule.directionLower;
    if (dir) {
      if ((dir.includes('money in') || dir.includes('in')) && amount <= 0) return false;
      if ((dir.includes('money out') || dir.includes('out')) && amount >= 0) return false;
    }

    if (compiledRule.amtCond && !compiledRule.amtCond(Math.abs(amount))) return false;

    return true;
  }

  function collectRulesUsage() {
    const rulesArray = Array.isArray(state.rules) ? state.rules : [];
    const compiled = [];
    const usage = [];

    rulesArray.forEach((rule, idx) => {
      const compiledRule = compileRuleForExport(rule, idx);
      if (!compiledRule) return;
      compiled.push(compiledRule);
      let originalRuleCopy;
      try {
        originalRuleCopy = JSON.parse(JSON.stringify(rule ?? {}));
      } catch (err) {
        originalRuleCopy = Object.assign({}, rule);
      }
      usage.push({
        index: idx,
        originalRule: originalRuleCopy,
        normalized: {
          pattern: compiledRule.pattern,
          rawPattern: compiledRule.rawPattern,
          regex: compiledRule.regex ? compiledRule.regex.source : null,
          regexFlags: compiledRule.regex ? compiledRule.regex.flags : '',
          category: compiledRule.category,
          direction: compiledRule.direction,
          hasAmountCondition: !!compiledRule.amtCond
        },
        matchCount: 0,
        sampleTransactions: []
      });
    });

    const transactions = Array.isArray(state.transactions) ? state.transactions : [];
    let categorizedCount = 0;

    transactions.forEach((tx, txIndex) => {
      if (!tx) return;
      const category = (tx['Schedule C Category'] || '').toString().trim();
      if (!category) return;
      categorizedCount += 1;
      if (compiled.length === 0) return;
      const categoryLower = category.toLowerCase();
      const desc = (tx.Description || tx.description || tx.Payee || '').toString();
      const descLower = desc.toLowerCase();
      const amount = parseAmount(tx['Amount'] ?? tx['amount'] ?? tx.Amount ?? 0);
      compiled.forEach((comp, compIdx) => {
        if (!comp || comp.categoryLower !== categoryLower) return;
        if (!ruleMatchesTransaction(comp, desc, descLower, amount)) return;
        const entry = usage[compIdx];
        entry.matchCount += 1;
        if (entry.sampleTransactions.length < 5) {
          entry.sampleTransactions.push({
            index: txIndex,
            Date: tx['Date'] ?? tx.Date ?? '',
            Description: desc,
            Payee: tx['Payee'] ?? '',
            Amount: amount,
            Category: category
          });
        }
      });
    });

    const matched = usage.filter(entry => entry.matchCount > 0);

    return {
      generatedAt: new Date().toISOString(),
      totalRules: rulesArray.length,
      compiledRules: usage.length,
      matchedRules: matched.length,
      unmatchedRules: usage.length - matched.length,
      skippedRules: Math.max(0, rulesArray.length - usage.length),
      totalTransactions: transactions.length,
      categorizedTransactions: categorizedCount,
    rules: matched
  };
}

  function formatRuleCsvValue(value) {
    return (value ?? '').toString().replace(/[\r\n]+/g, ' ').replace(/,/g, ' ').trim();
  }

  function buildRulesCsvContent(usage) {
    if (!usage || !Array.isArray(usage.rules)) return { content: '', count: 0 };
    const rows = [];
    usage.rules.forEach(entry => {
      if (!entry) return;
      const original = entry.originalRule || {};
      const patternSource = original.payee ?? original.match ?? original.pattern ?? entry.normalized?.rawPattern ?? entry.normalized?.pattern ?? '';
      const categorySource = original.category ?? original.Category ?? entry.normalized?.category ?? '';
      const directionSource =
        original.direction ?? original.type ?? original['Transaction Type'] ?? entry.normalized?.direction ?? '';
      const pattern = formatRuleCsvValue(patternSource);
      const category = formatRuleCsvValue(categorySource);
      const direction = formatRuleCsvValue(directionSource);
      if (!pattern && !category) return;
      rows.push([pattern, category, direction]);
    });
    if (rows.length === 0) return { content: '', count: 0 };
    const lines = rows.map(cols => cols.join(','));
    return { content: lines.join('\r\n'), count: rows.length };
  }

  function handleRulesCsvExportClick() {
    setExportMessage('export-rules-message', '');
    const usage = collectRulesUsage();
    if (!usage || usage.totalRules === 0) {
      setExportMessage('export-rules-message', 'No classification rules are loaded to export.', 'error');
      return;
    }
    if (!usage.rules || usage.rules.length === 0) {
      setExportMessage('export-rules-message', 'Loaded rules did not match any categorized transactions.', 'error');
      return;
    }
    const csv = buildRulesCsvContent(usage);
    if (!csv.content || csv.count === 0) {
      setExportMessage('export-rules-message', 'Matched rules do not contain exportable data.', 'error');
      return;
    }
    const stamp = new Date().toISOString().slice(0, 10);
    triggerDownload(`Rules_Export_${stamp}.csv`, `${csv.content}\r\n`, 'text/csv;charset=utf-8');
    setExportMessage(
      'export-rules-message',
      `Exported ${csv.count} rule${csv.count === 1 ? '' : 's'} in CSV format.`,
      'success'
    );
  }

  function handleCoaExportClick() {
    setExportMessage('export-coa-message', '');
    const result = generateCoaIifContent();
    if (!result.content || result.count === 0) {
      setExportMessage('export-coa-message', 'No accounts available to export. Add entries to the Chart of Accounts first.', 'error');
      return;
    }
    const stamp = new Date().toISOString().slice(0, 10);
    triggerIifDownload(`COA_Export_${stamp}.iif`, result.content);
    let message = `Exported ${result.count} account${result.count === 1 ? '' : 's'} to IIF.`;
    if (result.missingTypeCount > 0) {
      message += ` ${result.missingTypeCount} account${result.missingTypeCount === 1 ? '' : 's'} without a mapped QuickBooks type.`;
    }
    setExportMessage('export-coa-message', message, 'success');
  }

  function handleJournalExportClick() {
    const bankInput = document.getElementById('export-bank-account');
    const bankAccount = (bankInput?.value || '').trim();
    if (!bankAccount) {
      setExportMessage('export-journal-message', 'Enter the QuickBooks bank account name before exporting.', 'error');
      bankInput?.focus();
      return;
    }
    setExportMessage('export-journal-message', '');
    const result = generateJournalIifContent(bankAccount);
    if (!result.content || result.count === 0) {
      const parts = [];
      if (result.skipped?.missingCategory) parts.push(`${result.skipped.missingCategory} without a category`);
      if (result.skipped?.zeroAmount) parts.push(`${result.skipped.zeroAmount} with zero amount`);
      const reason = parts.length > 0 ? `Skipped ${parts.join(' and ')}.` : 'No categorized transactions available.';
      setExportMessage('export-journal-message', `Unable to export transactions. ${reason}`, 'error');
      return;
    }
    const stamp = new Date().toISOString().slice(0, 10);
    triggerIifDownload(`Journal_Export_${stamp}.iif`, result.content);
    const skippedParts = [];
    if (result.skipped?.missingCategory) skippedParts.push(`${result.skipped.missingCategory} without a category`);
    if (result.skipped?.zeroAmount) skippedParts.push(`${result.skipped.zeroAmount} with zero amount`);
    const suffix = skippedParts.length > 0 ? ` Skipped ${skippedParts.join(' and ')}.` : '';
    setExportMessage('export-journal-message', `Exported ${result.count} transaction${result.count === 1 ? '' : 's'} to IIF.${suffix}`, 'success');
  }

  function handleClassifiedExcelExport() {
    setExportMessage('export-classified-message', '');
    if (typeof XLSX === 'undefined' || !XLSX.utils || typeof XLSX.utils.aoa_to_sheet !== 'function') {
      setExportMessage('export-classified-message', 'Excel export unavailable (SheetJS not loaded).', 'error');
      return;
    }
    const rows = [['Date', 'Description', 'Amount', 'Schedule C Category']];
    let count = 0;
    const txs = Array.isArray(state.transactions) ? state.transactions : [];
    txs.forEach(tx => {
      if (!tx) return;
      const category = (resolveFieldValue(tx, 'Schedule C Category') || '').toString().trim();
      if (!category) return;
      const date = getTransactionCopyDate(tx) || '';
      const description = getTransactionCopyDescription(tx) || '';
      const rawAmount = resolveFieldValue(tx, 'Amount');
      const amountNumber = parseAmount(
        rawAmount !== undefined && rawAmount !== null && String(rawAmount).trim() !== ''
          ? rawAmount
          : (tx['Amount'] ?? tx['amount'] ?? tx.Amount ?? 0)
      );
      const amountValue = Number.isFinite(amountNumber) ? amountNumber : 0;
      rows.push([date, description, amountValue, category]);
      count++;
    });
    if (count === 0) {
      setExportMessage('export-classified-message', 'No categorized transactions available to export.', 'error');
      return;
    }
    const worksheet = XLSX.utils.aoa_to_sheet(rows);
    const workbook = XLSX.utils.book_new();
    XLSX.utils.book_append_sheet(workbook, worksheet, 'Classified');
    const wbout = XLSX.write(workbook, { bookType: 'xlsx', type: 'array' });
    const stamp = new Date().toISOString().slice(0, 10);
    triggerBinaryDownload(
      `Classified_Transactions_${stamp}.xlsx`,
      wbout,
      'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet'
    );
    setExportMessage(
      'export-classified-message',
      `Exported ${count} classified transaction${count === 1 ? '' : 's'} to Excel.`,
      'success'
    );
  }

  const exportCoaButton = document.getElementById('export-coa-button');
  if (exportCoaButton) exportCoaButton.addEventListener('click', handleCoaExportClick);
  const exportJournalButton = document.getElementById('export-journal-button');
  if (exportJournalButton) exportJournalButton.addEventListener('click', handleJournalExportClick);
  const exportRulesCsvButton = document.getElementById('export-rules-csv-button');
  if (exportRulesCsvButton) exportRulesCsvButton.addEventListener('click', handleRulesCsvExportClick);
  const exportClassifiedExcelButton = document.getElementById('export-classified-excel-button');
  if (exportClassifiedExcelButton) exportClassifiedExcelButton.addEventListener('click', handleClassifiedExcelExport);
  const copySelectionButton = document.getElementById('copy-selection-button');
  if (copySelectionButton) copySelectionButton.addEventListener('click', copySelectedTransactions);
  const copySelectionAssignedButton = document.getElementById('copy-selection-assigned');
  if (copySelectionAssignedButton) copySelectionAssignedButton.addEventListener('click', copySelectedTransactions);
  const reconcileSetButton = document.getElementById('reconcile-set-balances');
  if (reconcileSetButton) reconcileSetButton.addEventListener('click', openReconcileModal);
  const reconcileCancelButton = document.getElementById('reconcile-cancel');
  if (reconcileCancelButton) reconcileCancelButton.addEventListener('click', () => {
    closeReconcileModal();
  });
  const reconcileSaveButton = document.getElementById('reconcile-save');
  if (reconcileSaveButton) reconcileSaveButton.addEventListener('click', () => {
    const beginningInput = document.getElementById('reconcile-beginning-input');
    const statementInput = document.getElementById('reconcile-statement-input');
    const beginningVal = beginningInput ? Number(beginningInput.value) || 0 : 0;
    const statementVal = statementInput ? Number(statementInput.value) || 0 : 0;
    state.beginningBalance = beginningVal;
    state.statementBalance = statementVal;
    closeReconcileModal();
    updateReports();
    showMessage('Reconcile balances updated.', 'success', 2500);
  });
  const reconcileBeginningInput = document.getElementById('reconcile-beginning-input');
  if (reconcileBeginningInput) reconcileBeginningInput.addEventListener('input', updateReconcilePreview);
  const reconcileStatementInput = document.getElementById('reconcile-statement-input');
  if (reconcileStatementInput) reconcileStatementInput.addEventListener('input', updateReconcilePreview);
  const reconcileDetailAddButton = document.getElementById('reconcile-detail-add');
  if (reconcileDetailAddButton) reconcileDetailAddButton.addEventListener('click', () => openTransactionModal('add'));
  const transactionModalCancel = document.getElementById('transaction-modal-cancel');
  if (transactionModalCancel) transactionModalCancel.addEventListener('click', closeTransactionModal);
  const transactionModalClose = document.getElementById('transaction-modal-close');
  if (transactionModalClose) transactionModalClose.addEventListener('click', closeTransactionModal);
  const transactionModalSave = document.getElementById('transaction-modal-save');
  if (transactionModalSave) transactionModalSave.addEventListener('click', saveTransactionModal);
  const reconcileDetailToggle = document.getElementById('reconcile-detail-toggle');
  if (reconcileDetailToggle) reconcileDetailToggle.addEventListener('click', switchMonthlyDebitCredit);
  const reconcileDetailDeleteButton = document.getElementById('reconcile-detail-delete');
  if (reconcileDetailDeleteButton) reconcileDetailDeleteButton.addEventListener('click', deleteSelectedMonthlyTransactions);

  // === Auto-populate COA dropdowns when COA changes ===
  function refreshAllFromCoa() { refreshAllDropdowns(); }

  // === Startup ===
  function initSample() {
    // no sample COA entries by default; render current COA (empty initially)
    initCoaSortHeaders();
    renderCoa(); refreshAllDropdowns();
    updateReconcileView();
  }
  initSample();

  // Expose render functions for direct calls
  window.renderUnassigned = renderUnassigned; window.renderAssigned = renderAssigned; window.renderCoa = renderCoa; window.updateReports = updateReports; window.refreshAllDropdowns = refreshAllDropdowns;
  </script>
</body>
</html>
